// This file is part of the Essence operating system.
// It is released under the terms of the MIT license -- see LICENSE.md.
// Written by: nakst.

opaque_type EsElement          EsElementPublic;
opaque_type EsPanel            EsElement;
opaque_type EsWindow           EsElement;
opaque_type EsButton           EsElement;
opaque_type EsTextDisplay      EsElement;
opaque_type EsIconDisplay      EsElement;
opaque_type EsTextbox          EsElement;
opaque_type EsListView         EsElement;
opaque_type EsMenu             EsElement;
opaque_type EsColorWell        EsElement;
opaque_type EsSplitter         EsElement;
opaque_type EsImageDisplay     EsElement;
opaque_type EsListDisplay      EsElement;
opaque_type EsCanvasPane       EsElement;
opaque_type EsSlider           EsElement;
opaque_type EsScrollView       EsElement;
opaque_type EsSpacer           EsElement;
opaque_type EsTextPlan         none;
opaque_type EsPaintTarget      none;
opaque_type EsUndoManager      none;
opaque_type EsHeap             none;
opaque_type EsFileStore        none;
opaque_type EsUserTask         none;
opaque_type EsBundle           none;
opaque_type EsDialog           none;

type_name uint8_t EsNodeType;
type_name uintptr_t EsHandle;
type_name uint64_t EsFileOffset;
type_name int64_t EsFileOffsetDifference;
type_name uint64_t EsAudioDeviceID;
type_name uint16_t EsFontFamily;
type_name uint64_t EsTimer;
type_name int64_t EsListViewIndex;
type_name uint64_t EsObjectID;
type_name uint32_t EsDeviceColor; // TODO Make this 64-bit?
type_name uint32_t EsStyleID;

define ES_FLAGS_DEFAULT (0)

define ES_INVALID_HANDLE  ((EsHandle) (0))
define ES_CURRENT_THREAD  ((EsHandle) (0x10))
define ES_CURRENT_PROCESS ((EsHandle) (0x11))

define ES_WAIT_NO_TIMEOUT (-1)
define ES_MAX_WAIT_COUNT  (8)

define ES_MAX_DIRECTORY_CHILD_NAME_LENGTH (256)

define ES_PROCESS_EXECUTABLE_NOT_LOADED     (0)
define ES_PROCESS_EXECUTABLE_FAILED_TO_LOAD (1)
define ES_PROCESS_EXECUTABLE_LOADED         (2)

define ES_SNAPSHOT_MAX_PROCESS_NAME_LENGTH (31)
define ES_SYSTEM_SNAPSHOT_PROCESSES        (1)

// Message responses:
// 0 is unhandled.
define ES_HANDLED  (-1)
define ES_REJECTED (-2)

define ES_NODE_FILE      (0x00)
define ES_NODE_DIRECTORY (0x10)
define ES_NODE_INVALID   (0x20)

define ES_DIRECTORY_CHILDREN_UNKNOWN ((EsFileOffsetDifference) (-1))

define ES_MEMORY_MAP_OBJECT_ALL (0) // Set size to this to map the entire object.

define ES_SHARED_MEMORY_READ_WRITE (1 << 0)

define ES_STRING_FORMAT_ENOUGH_SPACE (-1)

define ES_PANEL_BAND_SIZE_DEFAULT (-1)

define ES_SCROLLBAR_VERTICAL   (0 << 0)
define ES_SCROLLBAR_HORIZONTAL (1 << 0)

// Standard font families:
define ES_FONT_SANS       (0xFFFF)
define ES_FONT_SERIF      (0xFFFE)
define ES_FONT_MONOSPACED (0xFFFD)

// Font weights:
define ES_FONT_REGULAR  (4)
define ES_FONT_SEMIBOLD (6)
define ES_FONT_BOLD     (7)

define ES_COMMAND_SYSTEM_START		(0xF0000000)
define ES_COMMAND_DELETE		(0xF0000001)
define ES_COMMAND_SELECT_ALL		(0xF0000002)
define ES_COMMAND_CUT			(0xF0000003)
define ES_COMMAND_COPY			(0xF0000004)
define ES_COMMAND_PASTE			(0xF0000005)
define ES_COMMAND_UNDO			(0xF0000006)
define ES_COMMAND_REDO			(0xF0000007)
define ES_COMMAND_SAVE			(0xF0000008)
define ES_COMMAND_SHOW_IN_FILE_MANAGER	(0xF0000009)

define ES_WINDOW_MOVE_MAXIMIZED (1 << 0)
define ES_WINDOW_MOVE_ADJUST_TO_FIT_SCREEN (1 << 1)
define ES_WINDOW_MOVE_HIDDEN (1 << 2)
define ES_WINDOW_MOVE_ALWAYS_ON_TOP (1 << 3)
define ES_WINDOW_MOVE_AT_BOTTOM (1 << 4)
define ES_WINDOW_MOVE_UPDATE_SCREEN (1 << 5)
define ES_WINDOW_MOVE_DYNAMIC (1 << 6)

define ES_WINDOW_SOLID_TRUE (1 << 0)
define ES_WINDOW_SOLID_NO_ACTIVATE (1 << 1)
define ES_WINDOW_SOLID_NO_BRING_TO_FRONT (1 << 2)

define ES_GAME_CONTROLLER_MAX_COUNT (16)

define ES_DOMAIN_NAME_MAX_LENGTH (255)
define ES_ECHO_REQUEST_MAX_LENGTH (48)

define ES_INSTANCE_CLASS_VIEWER (0) // Default.
define ES_INSTANCE_CLASS_EDITOR (1)

define ES_MOUNT_POINT_MAX_COUNT (256)

define ES_THREAD_EVENT_MUTEX_ACQUIRE (1)
define ES_THREAD_EVENT_MUTEX_RELEASE (2)

define ES_WINDOW_PROPERTY_SOLID         (0x01) // Standard window properties.
define ES_WINDOW_PROPERTY_OPAQUE_BOUNDS (0x02)
define ES_WINDOW_PROPERTY_BLUR_BOUNDS   (0x03)
define ES_WINDOW_PROPERTY_ALPHA         (0x04)
define ES_WINDOW_PROPERTY_FOCUSED       (0x05)
define ES_WINDOW_PROPERTY_MATERIAL      (0x06)
define ES_WINDOW_PROPERTY_EMBED         (0x07)
define ES_WINDOW_PROPERTY_EMBED_INSETS  (0x08)
define ES_WINDOW_PROPERTY_OBJECT        (0x81) // Embedded window properties.
define ES_WINDOW_PROPERTY_EMBED_OWNER   (0x82)

define ES_DRAW_BITMAP_OPAQUE (0xFFFF)
define ES_DRAW_BITMAP_XOR    (0xFFFE)
define ES_DRAW_BITMAP_BLEND  (0)

define ES_SCROLL_WHEEL_NOTCH (0x100)

define ES_SHUTDOWN_ACTION_POWER_OFF (1)
define ES_SHUTDOWN_ACTION_RESTART (2)

inttype EsScancode uint16_t none {
	ES_SCANCODE_A = 			(0x04)
	ES_SCANCODE_B = 			(0x05)
	ES_SCANCODE_C = 			(0x06)
	ES_SCANCODE_D = 			(0x07)
	ES_SCANCODE_E = 			(0x08)
	ES_SCANCODE_F = 			(0x09)
	ES_SCANCODE_G = 			(0x0A)
	ES_SCANCODE_H = 			(0x0B)
	ES_SCANCODE_I = 			(0x0C)
	ES_SCANCODE_J = 			(0x0D)
	ES_SCANCODE_K = 			(0x0E)
	ES_SCANCODE_L = 			(0x0F)
	ES_SCANCODE_M = 			(0x10)
	ES_SCANCODE_N = 			(0x11)
	ES_SCANCODE_O = 			(0x12)
	ES_SCANCODE_P = 			(0x13)
	ES_SCANCODE_Q = 			(0x14)
	ES_SCANCODE_R = 			(0x15)
	ES_SCANCODE_S = 			(0x16)
	ES_SCANCODE_T = 			(0x17)
	ES_SCANCODE_U = 			(0x18)
	ES_SCANCODE_V = 			(0x19)
	ES_SCANCODE_W = 			(0x1A)
	ES_SCANCODE_X = 			(0x1B)
	ES_SCANCODE_Y = 			(0x1C)
	ES_SCANCODE_Z = 			(0x1D)

	ES_SCANCODE_1 = 			(0x1E)
	ES_SCANCODE_2 = 			(0x1F)
	ES_SCANCODE_3 = 			(0x20)
	ES_SCANCODE_4 = 			(0x21)
	ES_SCANCODE_5 = 			(0x22)
	ES_SCANCODE_6 = 			(0x23)
	ES_SCANCODE_7 = 			(0x24)
	ES_SCANCODE_8 = 			(0x25)
	ES_SCANCODE_9 = 			(0x26)
	ES_SCANCODE_0 = 			(0x27)

	ES_SCANCODE_ENTER =  			(0x28)
	ES_SCANCODE_ESCAPE = 			(0x29)
	ES_SCANCODE_BACKSPACE = 		(0x2A)
	ES_SCANCODE_TAB = 			(0x2B)
	ES_SCANCODE_SPACE = 			(0x2C)

	ES_SCANCODE_HYPHEN = 			(0x2D)
	ES_SCANCODE_EQUALS = 			(0x2E)
	ES_SCANCODE_LEFT_BRACE = 		(0x2F)
	ES_SCANCODE_RIGHT_BRACE = 		(0x30)
	ES_SCANCODE_COMMA = 			(0x36)
	ES_SCANCODE_PERIOD = 			(0x37)
	ES_SCANCODE_SLASH = 			(0x38)
	ES_SCANCODE_PUNCTUATION_1 = 		(0x31) // On US keyboard, \|
	ES_SCANCODE_PUNCTUATION_2 = 		(0x32) // Not on US keyboard
	ES_SCANCODE_PUNCTUATION_3 = 		(0x33) // On US keyboard, ;:
	ES_SCANCODE_PUNCTUATION_4 = 		(0x34) // On US keyboard, '"
	ES_SCANCODE_PUNCTUATION_5 = 		(0x35) // On US keyboard, `~
	ES_SCANCODE_PUNCTUATION_6 = 		(0x64) // Not on US keyboard

	ES_SCANCODE_F1 = 			(0x3A)
	ES_SCANCODE_F2 = 			(0x3B)
	ES_SCANCODE_F3 = 			(0x3C)
	ES_SCANCODE_F4 = 			(0x3D)
	ES_SCANCODE_F5 = 			(0x3E)
	ES_SCANCODE_F6 = 			(0x3F)
	ES_SCANCODE_F7 = 			(0x40)
	ES_SCANCODE_F8 = 			(0x41)
	ES_SCANCODE_F9 = 			(0x42)
	ES_SCANCODE_F10 = 			(0x43)
	ES_SCANCODE_F11 = 			(0x44)
	ES_SCANCODE_F12 = 			(0x45)
	ES_SCANCODE_F13 = 			(0x68)
	ES_SCANCODE_F14 = 			(0x69)
	ES_SCANCODE_F15 = 			(0x6A)
	ES_SCANCODE_F16 = 			(0x6B)
	ES_SCANCODE_F17 = 			(0x6C)
	ES_SCANCODE_F18 = 			(0x6D)
	ES_SCANCODE_F19 = 			(0x6E)
	ES_SCANCODE_F20 = 			(0x6F)
	ES_SCANCODE_F21 = 			(0x70)
	ES_SCANCODE_F22 = 			(0x71)
	ES_SCANCODE_F23 = 			(0x72)
	ES_SCANCODE_F24 = 			(0x73)

	ES_SCANCODE_CAPS_LOCK = 		(0x39)
	ES_SCANCODE_PRINT_SCREEN = 		(0x46)
	ES_SCANCODE_SCROLL_LOCK = 		(0x47)
	ES_SCANCODE_PAUSE = 			(0x48)
	ES_SCANCODE_INSERT = 			(0x49)
	ES_SCANCODE_HOME = 			(0x4A)
	ES_SCANCODE_PAGE_UP = 			(0x4B)
	ES_SCANCODE_DELETE = 			(0x4C)
	ES_SCANCODE_END = 			(0x4D)
	ES_SCANCODE_PAGE_DOWN = 		(0x4E)
	ES_SCANCODE_RIGHT_ARROW = 		(0x4F)
	ES_SCANCODE_LEFT_ARROW = 		(0x50)
	ES_SCANCODE_DOWN_ARROW = 		(0x51)
	ES_SCANCODE_UP_ARROW = 			(0x52)
	ES_SCANCODE_NUM_LOCK = 			(0x53)
	ES_SCANCODE_CONTEXT_MENU =  		(0x65)
	ES_SCANCODE_SYSTEM_REQUEST = 		(0x9A)

	ES_SCANCODE_ACTION_EXECUTE = 		(0x74)
	ES_SCANCODE_ACTION_HELP = 		(0x75)
	ES_SCANCODE_ACTION_MENU = 		(0x76)
	ES_SCANCODE_ACTION_SELECT = 		(0x77)
	ES_SCANCODE_ACTION_STOP = 		(0x78)
	ES_SCANCODE_ACTION_AGAIN = 		(0x79)
	ES_SCANCODE_ACTION_UNDO = 		(0x7A)
	ES_SCANCODE_ACTION_CUT = 		(0x7B)
	ES_SCANCODE_ACTION_COPY = 		(0x7C)
	ES_SCANCODE_ACTION_PASTE = 		(0x7D)
	ES_SCANCODE_ACTION_FIND = 		(0x7E)
	ES_SCANCODE_ACTION_CANCEL = 		(0x9B)
	ES_SCANCODE_ACTION_CLEAR = 		(0x9C)
	ES_SCANCODE_ACTION_PRIOR = 		(0x9D)
	ES_SCANCODE_ACTION_RETURN = 		(0x9E)
	ES_SCANCODE_ACTION_SEPARATOR = 		(0x9F)

	ES_SCANCODE_MM_MUTE = 			(0x7F)
	ES_SCANCODE_MM_LOUDER = 		(0x80)
	ES_SCANCODE_MM_QUIETER = 		(0x81)
	ES_SCANCODE_MM_NEXT = 			(0x103)
	ES_SCANCODE_MM_PREVIOUS = 		(0x104)
	ES_SCANCODE_MM_STOP = 			(0x105)
	ES_SCANCODE_MM_PAUSE = 			(0x106)
	ES_SCANCODE_MM_SELECT = 		(0x107)
	ES_SCANCODE_MM_EMAIL = 			(0x108)
	ES_SCANCODE_MM_CALC = 			(0x109)
	ES_SCANCODE_MM_FILES = 			(0x10A)

	ES_SCANCODE_INTERNATIONAL_1 = 		(0x87)
	ES_SCANCODE_INTERNATIONAL_2 = 		(0x88)
	ES_SCANCODE_INTERNATIONAL_3 = 		(0x89)
	ES_SCANCODE_INTERNATIONAL_4 = 		(0x8A)
	ES_SCANCODE_INTERNATIONAL_5 = 		(0x8B)
	ES_SCANCODE_INTERNATIONAL_6 = 		(0x8C)
	ES_SCANCODE_INTERNATIONAL_7 = 		(0x8D)
	ES_SCANCODE_INTERNATIONAL_8 = 		(0x8E)
	ES_SCANCODE_INTERNATIONAL_9 = 		(0x8F)

	ES_SCANCODE_HANGUL_ENGLISH_TOGGLE = 	(0x90)
	ES_SCANCODE_HANJA_CONVERSION = 		(0x91)
	ES_SCANCODE_KATAKANA = 			(0x92)
	ES_SCANCODE_HIRAGANA = 			(0x93)
	ES_SCANCODE_HANKAKU_ZENKAKU_TOGGLE = 	(0x94)
	ES_SCANCODE_ALTERNATE_ERASE = 		(0x99)

	ES_SCANCODE_THOUSANDS_SEPARATOR = 	(0xB2)
	ES_SCANCODE_DECIMAL_SEPARATOR = 	(0xB3)
	ES_SCANCODE_CURRENCY_UNIT = 		(0xB4)
	ES_SCANCODE_CURRENCY_SUBUNIT = 		(0xB5)

	ES_SCANCODE_NUM_DIVIDE = 		(0x54)
	ES_SCANCODE_NUM_MULTIPLY = 		(0x55)
	ES_SCANCODE_NUM_SUBTRACT = 		(0x56)
	ES_SCANCODE_NUM_ADD = 			(0x57)
	ES_SCANCODE_NUM_ENTER = 		(0x58)
	ES_SCANCODE_NUM_1 = 			(0x59)
	ES_SCANCODE_NUM_2 = 			(0x5A)
	ES_SCANCODE_NUM_3 = 			(0x5B)
	ES_SCANCODE_NUM_4 = 			(0x5C)
	ES_SCANCODE_NUM_5 = 			(0x5D)
	ES_SCANCODE_NUM_6 = 			(0x5E)
	ES_SCANCODE_NUM_7 = 			(0x5F)
	ES_SCANCODE_NUM_8 = 			(0x60)
	ES_SCANCODE_NUM_9 = 			(0x61)
	ES_SCANCODE_NUM_0 = 			(0x62)
	ES_SCANCODE_NUM_POINT = 		(0x63)
	ES_SCANCODE_NUM_EQUALS = 		(0x67)
	ES_SCANCODE_NUM_COMMA = 		(0x82)
	ES_SCANCODE_NUM_00 = 			(0xB0)
	ES_SCANCODE_NUM_000 = 			(0xB1)
	ES_SCANCODE_NUM_LEFT_PAREN = 		(0xB6)
	ES_SCANCODE_NUM_RIGHT_PAREN = 		(0xB7)
	ES_SCANCODE_NUM_LEFT_BRACE = 		(0xB8)
	ES_SCANCODE_NUM_RIGHT_BRACE = 		(0xB9)
	ES_SCANCODE_NUM_TAB = 			(0xBA)
	ES_SCANCODE_NUM_BACKSPACE = 		(0xBB)
	ES_SCANCODE_NUM_A = 			(0xBC)
	ES_SCANCODE_NUM_B = 			(0xBD)
	ES_SCANCODE_NUM_C = 			(0xBE)
	ES_SCANCODE_NUM_D = 			(0xBF)
	ES_SCANCODE_NUM_E = 			(0xC0)
	ES_SCANCODE_NUM_F = 			(0xC1)
	ES_SCANCODE_NUM_XOR = 			(0xC2)
	ES_SCANCODE_NUM_CARET = 		(0xC3)
	ES_SCANCODE_NUM_PERCENT = 		(0xC4)
	ES_SCANCODE_NUM_LESS_THAN = 		(0xC5)
	ES_SCANCODE_NUM_GREATER_THAN = 		(0xC6)
	ES_SCANCODE_NUM_AMPERSAND = 		(0xC7)
	ES_SCANCODE_NUM_DOUBLE_AMPERSAND = 	(0xC8)
	ES_SCANCODE_NUM_BAR = 			(0xC9)
	ES_SCANCODE_NUM_DOUBLE_BAR = 		(0xCA)
	ES_SCANCODE_NUM_COLON = 		(0xCB)
	ES_SCANCODE_NUM_HASH = 			(0xCC)
	ES_SCANCODE_NUM_SPACE = 		(0xCD)
	ES_SCANCODE_NUM_AT = 			(0xCE)
	ES_SCANCODE_NUM_EXCLAMATION_MARK = 	(0xCF)
	ES_SCANCODE_NUM_MEMORY_STORE = 		(0xD0)
	ES_SCANCODE_NUM_MEMORY_RECALL = 	(0xD1)
	ES_SCANCODE_NUM_MEMORY_CLEAR = 		(0xD2)
	ES_SCANCODE_NUM_MEMORY_ADD = 		(0xD3)
	ES_SCANCODE_NUM_MEMORY_SUBTRACT = 	(0xD4)
	ES_SCANCODE_NUM_MEMORY_MULTIPLY = 	(0xD5)
	ES_SCANCODE_NUM_MEMORY_DIVIDE = 	(0xD6)
	ES_SCANCODE_NUM_NEGATE = 		(0xD7)
	ES_SCANCODE_NUM_CLEAR_ALL = 		(0xD8)
	ES_SCANCODE_NUM_CLEAR = 		(0xD9)
	ES_SCANCODE_NUM_BINARY = 		(0xDA)
	ES_SCANCODE_NUM_OCTAL = 		(0xDB)
	ES_SCANCODE_NUM_DECIMAL = 		(0xDC)
	ES_SCANCODE_NUM_HEXADECIMAL = 		(0xDD)

	ES_SCANCODE_LEFT_CTRL = 		(0xE0)
	ES_SCANCODE_LEFT_SHIFT = 		(0xE1)
	ES_SCANCODE_LEFT_ALT = 			(0xE2)
	ES_SCANCODE_LEFT_FLAG = 		(0xE3)
	ES_SCANCODE_RIGHT_CTRL = 		(0xE4)
	ES_SCANCODE_RIGHT_SHIFT = 		(0xE5)
	ES_SCANCODE_RIGHT_ALT = 		(0xE6)
	ES_SCANCODE_RIGHT_FLAG = 		(0xE7)

	ES_SCANCODE_ACPI_POWER =  		(0x100)
	ES_SCANCODE_ACPI_SLEEP =  		(0x101)
	ES_SCANCODE_ACPI_WAKE =   		(0x102)

	ES_SCANCODE_WWW_SEARCH = 		(0x10B)
	ES_SCANCODE_WWW_HOME = 			(0x10C)
	ES_SCANCODE_WWW_BACK = 			(0x10D)
	ES_SCANCODE_WWW_FORWARD = 		(0x10E)
	ES_SCANCODE_WWW_STOP = 			(0x10F)
	ES_SCANCODE_WWW_REFRESH = 		(0x110)
	ES_SCANCODE_WWW_STARRED = 		(0x111)
};

inttype EsProcessStateFlags uint8_t none {
	ES_PROCESS_STATE_ALL_THREADS_TERMINATED = bit 0
	ES_PROCESS_STATE_TERMINATING = bit 1
	ES_PROCESS_STATE_CRASHED = bit 2
	ES_PROCESS_STATE__PINGED = bit 3
	ES_PROCESS_STATE__PAUSED_FROM_CRASH = bit 4
};

inttype EsError intptr_t none {
	ES_SUCCESS = -1

	// Networking errors:
	ES_ERROR_NO_ADDRESS_FOR_DOMAIN_NAME = -1000
	ES_ERROR_NO_CONNECTED_NETWORK_INTERFACES = -1001
	ES_ERROR_BAD_DOMAIN_NAME = -1002
	ES_ERROR_LOST_IP_ADDRESS = -1003
	ES_ERROR_CONNECTION_RESET = -1004
	ES_ERROR_CONNECTION_REFUSED = -1005
	ES_ERROR_BUFFER_TOO_SMALL = -1006

	// File system errors:
	ES_ERROR_OPERATION_BLOCKED = -2000 // Somebody else has opened the node with flags blocking this operation.
	ES_ERROR_ACCESS_NOT_WITHIN_FILE_BOUNDS = -2001 
	ES_ERROR_DIRECTORY_NOT_EMPTY = -2004
	ES_ERROR_NODE_DELETED = -2005
	ES_ERROR_FILE_TOO_LARGE = -2006 // Errors caused by the file being too large. For example, the file system might impose a maximum size limit on files, or it might impose a limit on how fragmented a file may become.
	ES_ERROR_DRIVE_FULL = -2007
	ES_ERROR_CORRUPT_DATA = -2008
	ES_ERROR_INVALID_NAME = -2009
	ES_ERROR_FILE_ON_READ_ONLY_VOLUME = -2011
	ES_ERROR_PATH_NOT_WITHIN_MOUNTED_VOLUME = -2013
	ES_ERROR_PATH_NOT_TRAVERSABLE = -2014
	ES_ERROR_DEVICE_REMOVED = -2015
	ES_ERROR_INCORRECT_NODE_TYPE = -2016
	ES_ERROR_FILE_DOES_NOT_EXIST = -2017
	ES_ERROR_COULD_NOT_RESIZE_FILE = -2018 // TODO Replace with ERROR_HARDWARE_FAILURE/ERROR_CORRUPT_DATA/ERROR_DRIVE_FULL/ERROR_FILE_TOO_LARGE.
	ES_ERROR_VOLUME_MISMATCH = -2019
	ES_ERROR_TARGET_WITHIN_SOURCE = -2020

	// General errors:
	ES_ERROR_UNKNOWN = -3000
	ES_ERROR_ALREADY_EXISTS = -3001
	ES_ERROR_CANCELLED = -3002
	ES_ERROR_INSUFFICIENT_RESOURCES = -3003
	ES_ERROR_PERMISSION_NOT_GRANTED = -3004
	ES_ERROR_UNSUPPORTED = -3005
	ES_ERROR_HARDWARE_FAILURE = -3006 

	// Internal errors (not be returned by any API function):
	ES_ERROR_NODE_NOT_LOADED = -4001
	ES_ERROR_DIRECTORY_ENTRY_BEING_REMOVED = -4002
	ES_ERROR_COULD_NOT_RESOLVE_SYMBOL = -4003
	ES_ERROR_NO_MESSAGES_AVAILABLE = -4004
	ES_ERROR_INVALID_DIMENSIONS = -4005
	ES_ERROR_TOO_MANY_FILES_WITH_NAME = -4006

	// Errors specific to a single function:
	ES_ERROR_MESSAGE_QUEUE_FULL = -5000 // EsMessagePost.
	ES_ERROR_TIMEOUT_REACHED = -5001 // EsWait.
	ES_ERROR_BLOCK_ACCESS_INVALID = -5002 // ES_DEVICE_CONTROL_BLOCK_READ/ES_DEVICE_CONTROL_BLOCK_WRITE.
};

inttype EsTextFlags uint32_t none {
	ES_TEXT_H_LEFT = bit 0
	ES_TEXT_H_CENTER = bit 1
	ES_TEXT_H_RIGHT = bit 2
	ES_TEXT_V_TOP = bit 3
	ES_TEXT_V_CENTER = bit 4
	ES_TEXT_V_BOTTOM = bit 5
	ES_TEXT_ELLIPSIS = bit 6
	ES_TEXT_WRAP = bit 7
};

inttype EsTextPlanFlags uint32_t EsTextFlags {
	ES_TEXT_PLAN_SINGLE_USE = bit 8
	ES_TEXT_PLAN_TRIM_SPACES = bit 9
	ES_TEXT_PLAN_RTL = bit 10
	ES_TEXT_PLAN_CLIP_UNBREAKABLE_LINES = bit 11
	ES_TEXT_PLAN_NO_FONT_SUBSTITUTION = bit 12
};

inttype EsDrawContentFlags uint32_t EsTextFlags {
	ES_DRAW_CONTENT_TABULAR = bit 8
	ES_DRAW_CONTENT_MARKER_DOWN_ARROW = bit 9
	ES_DRAW_CONTENT_MARKER_UP_ARROW = bit 10
	ES_DRAW_CONTENT_RICH_TEXT = bit 11
};

inttype EsListViewColumnFlags uint32_t EsDrawContentFlags {
	ES_LIST_VIEW_COLUMN_HAS_MENU           =    bit 16  // The header can be clicked to open a menu.
	ES_LIST_VIEW_COLUMN_DATA_STRINGS       = ( 0 << 22) // Data types for fixed items or GET_ITEM_DATA.
	ES_LIST_VIEW_COLUMN_DATA_INTEGERS      = ( 1 << 22)
	ES_LIST_VIEW_COLUMN_DATA_DOUBLES       = ( 2 << 22)
	ES_LIST_VIEW_COLUMN_DATA_MASK          = ( 3 << 22)
	ES_LIST_VIEW_COLUMN_SORT_DEFAULT       = ( 0 << 24) // Sort types for fixed items or GET_ITEM_DATA.
	ES_LIST_VIEW_COLUMN_SORT_TIME          = ( 1 << 24)
	ES_LIST_VIEW_COLUMN_SORT_SIZE          = ( 2 << 24)
	ES_LIST_VIEW_COLUMN_SORT_NONE          = ( 3 << 24)
	ES_LIST_VIEW_COLUMN_SORT_MASK          = ( 7 << 24)
	ES_LIST_VIEW_COLUMN_FORMAT_DEFAULT     = ( 0 << 27) // Format types for fixed items or GET_ITEM_DATA.
	ES_LIST_VIEW_COLUMN_FORMAT_YES_NO      = ( 1 << 27)
	ES_LIST_VIEW_COLUMN_FORMAT_ON_OFF      = ( 2 << 27)
	ES_LIST_VIEW_COLUMN_FORMAT_PERCENTAGE  = ( 3 << 27)
	ES_LIST_VIEW_COLUMN_FORMAT_BYTES       = ( 4 << 27)
	ES_LIST_VIEW_COLUMN_FORMAT_BITS        = ( 5 << 27) 
	ES_LIST_VIEW_COLUMN_FORMAT_BYTE_RATE   = ( 6 << 27) // Bytes per second.
	ES_LIST_VIEW_COLUMN_FORMAT_SECONDS     = ( 7 << 27) 
	ES_LIST_VIEW_COLUMN_FORMAT_HERTZ       = ( 8 << 27) 
	ES_LIST_VIEW_COLUMN_FORMAT_PIXELS      = ( 9 << 27)
	ES_LIST_VIEW_COLUMN_FORMAT_DPI         = (10 << 27)
	ES_LIST_VIEW_COLUMN_FORMAT_ENUM_STRING = (11 << 27)
	ES_LIST_VIEW_COLUMN_FORMAT_MASK        = (31 << 27)
};

// For ES_MSG_LIST_VIEW_GET_COLUMN_SORT.
inttype EsListViewGetColumnSortFlags uint32_t none {
	ES_LIST_VIEW_COLUMN_SORT_ASCENDING = bit 0
	ES_LIST_VIEW_COLUMN_SORT_DESCENDING = bit 1
};

inttype EsFileOpenFlags uint32_t none {
	// TODO Cleanup!

	ES_FILE_READ_SHARED = bit 0		 // Read-only. The file can still be opened for writing.
	ES_FILE_READ = bit 1			 // Read-only. The file will not openable for writing. This will fail if the file is already opened for writing.
	ES_FILE_WRITE_SHARED = bit 2		 // Read-write. The file can still be opened for writing. This will fail if the file is already opened for exclusive writing.
	ES_FILE_WRITE = bit 3 			 // Read-write. The file will not openable for writing. This will fail if the file is already opened for writing.

	ES_NODE_FAIL_IF_FOUND = bit 16
	ES_NODE_FAIL_IF_NOT_FOUND = bit 17
	ES_NODE_PREVENT_RESIZE = bit 18
	ES_NODE_CREATE_DIRECTORIES = bit 19 	// Create the directories leading to the file, if they don't already exist.

	ES__NODE_FROM_WRITE_EXCLUSIVE = bit 21
	ES__NODE_DIRECTORY_WRITE = bit 22
	ES__NODE_NO_WRITE_BASE = bit 23
};

inttype EsMemoryMapFlags uint32_t none {
	ES_MEMORY_MAP_OBJECT_READ_WRITE = bit 0
	ES_MEMORY_MAP_OBJECT_READ_ONLY = bit 1
	ES_MEMORY_MAP_OBJECT_COPY_ON_WRITE = bit 2 // Files only.
};

// Flags set with %f.
inttype EsStringFormatFlags uint32_t none {
	ES_STRING_FORMAT_SIMPLE = bit 0
};

define ES_PERMISSION_ALL ((_EsLongConstant) (-1))
inttype EsProcessPermissions uint64_t none {
	ES_PERMISSION_NETWORKING = bit 0
	ES_PERMISSION_PROCESS_CREATE = bit 1
	ES_PERMISSION_PROCESS_OPEN = bit 2
	ES_PERMISSION_SCREEN_MODIFY = bit 3
	ES_PERMISSION_SHUTDOWN = bit 4
	ES_PERMISSION_TAKE_SYSTEM_SNAPSHOT = bit 5
	ES_PERMISSION_GET_VOLUME_INFORMATION = bit 6
	ES_PERMISSION_WINDOW_MANAGER = bit 7
	ES_PERMISSION_POSIX_SUBSYSTEM = bit 8
	ES_PERMISSION_INHERIT = bit 63
};

// Element flags - bits 0-31 for custom use; bits 32-63 common to all elements.

inttype EsElementFlags uint64_t none {
	// Common element flags:
	ES_ELEMENT_FOCUSABLE = bit 32
	ES_ELEMENT_HIDDEN = bit 33 // Hides the element and descendents. Also prevents the element and descendents from taking focus or being hovered/pressed.
	ES_ELEMENT_DISABLED = bit 34 // Prevents the element from taking focus or being pressed.
	ES_ELEMENT_DEBUG = bit 35 // Prints some extra debug information about the element.
	ES_ELEMENT_NO_CLIP = bit 36 // Do not clip children to the element's bounds.
	ES_ELEMENT_NO_HOVER = bit 37 // For z-stacked elements. Can still hover descendents and overlapped siblings/parent. Override HIT_TEST to return false to prevent hovering descendents.
	ES_ELEMENT_NO_HOVER_DESCENDENTS = bit 38 // Prevent hovering over any descendents.
	ES_ELEMENT_BLOCK_FOCUS = bit 39 // This element and descendents cannot take focus.
	ES_ELEMENT_NOT_TAB_TRAVERSABLE = bit 40 // Use with ES_ELEMENT_FOCUSABLE to indicate the element cannot be focused from tab traversal.
	ES_ELEMENT_NO_FOCUS_ON_CLICK = bit 41 // Use with ES_ELEMENT_FOCUSABLE to indicate the element cannot be focused by clicking it.
	ES_ELEMENT_LAYOUT_HINT_HORIZONTAL = bit 43 // Hint for autoCorners and autoBorders.
	ES_ELEMENT_LAYOUT_HINT_REVERSE = bit 44 // Hint for autoCorners and autoBorders; and tab traversal.
	ES_ELEMENT_STICKY_ACCESS_KEY = bit 45 // Don't exit access key mode after using the access key.
	ES_ELEMENT_NON_CLIENT = bit 46 
	ES_ELEMENT_FREE_USER_DATA = bit 47 // Call EsHeapFree on userData when destroying the element.
	ES_ELEMENT_AUTO_GROUP = bit 48 // Enables autoCorners and autoBorders.

	// For children of splitters:
	ES_CELL_COLLAPSABLE = bit 51

	// Cell layout flags:
	ES_CELL_H_PUSH = bit 54
	ES_CELL_H_EXPAND = bit 55
	ES_CELL_H_SHRINK = bit 56
	ES_CELL_H_LEFT = bit 57
	ES_CELL_H_RIGHT = bit 58
	ES_CELL_V_PUSH = bit 59
	ES_CELL_V_EXPAND = bit 60
	ES_CELL_V_SHRINK = bit 61
	ES_CELL_V_TOP = bit 62
	ES_CELL_V_BOTTOM = bit 63
};

inttype EsPanelFlags uint64_t EsElementFlags {
	// Defaults.
	ES_PANEL_STACK			= 0
	ES_PANEL_VERTICAL		= 0
	ES_PANEL_SWITCHER_MEASURE_SHOWN = 0 // Use the shown child to determine size.

	ES_PANEL_SWITCHER = bit 0
	ES_PANEL_Z_STACK = bit 1
	ES_PANEL_TABLE = bit 2

	ES_PANEL_H_SCROLL_FIXED = bit 4
	ES_PANEL_V_SCROLL_FIXED = bit 5
	ES_PANEL_H_SCROLL_AUTO = bit 6
	ES_PANEL_V_SCROLL_AUTO = bit 7

	// For ES_PANEL_TABLE and ES_PANEL_STACK.
	ES_PANEL_HORIZONTAL = bit 8
	ES_PANEL_REVERSE = bit 9 // Reverse layout is not supported with ES_PANEL_TABLE yet.

	// For ES_PANEL_SWITCHER.
	ES_PANEL_SWITCHER_MEASURE_LARGEST = bit 15 // Use the largest child to determine size.

	// For ES_PANEL_TABLE.
	ES_PANEL_TABLE_H_JUSTIFY = bit 16
	ES_PANEL_TABLE_V_JUSTIFY = bit 17

	ES_PANEL_RADIO_GROUP = bit 30 // Determines how arrow keys/tabs behave.
};

inttype EsTextboxFlags uint64_t EsElementFlags {
	ES_TEXTBOX_MULTILINE = bit 0
	ES_TEXTBOX_EDIT_BASED = bit 1
	ES_TEXTBOX_MARGIN = bit 2
	ES_TEXTBOX_NO_SMART_CONTEXT_MENUS = bit 3
	ES_TEXTBOX_ALLOW_TABS = bit 4
	ES_TEXTBOX_REJECT_EDIT_IF_LOST_FOCUS = bit 5
}

inttype EsTextboxFindFlags uint32_t none {
	ES_TEXTBOX_FIND_BACKWARDS = bit 0
};

inttype EsTextboxGetContentsFlags uint32_t none {
	ES_TEXTBOX_GET_CONTENTS_SELECTED_ONLY = bit 0
};

// First few bits reserved for the check state.
define ES_MENU_ITEM_CHECKED (ES_CHECK_CHECKED)
inttype EsButtonFlags uint64_t EsElementFlags {
	ES_BUTTON_DEFAULT = bit 3
	ES_BUTTON_MENU_ITEM = bit 4
	ES_BUTTON_NOT_FOCUSABLE = bit 5
	ES_BUTTON_TOOLBAR = bit 6
	ES_BUTTON_DROPDOWN = bit 7
	ES_BUTTON_COMPACT = bit 8
	ES_BUTTON_CHECKBOX = bit 9
	ES_BUTTON_RADIOBOX = bit 10
	ES_BUTTON_CANCEL = bit 11
	ES_BUTTON_PUSH = bit 12
};
inttype EsMenuItemFlags uint64_t EsButtonFlags {
	ES_MENU_ITEM_HEADER = bit 31
};

inttype EsColorWellFlags uint64_t EsElementFlags {
	ES_COLOR_WELL_HAS_OPACITY = bit 0
};

inttype EsSplitterFlags uint64_t EsElementFlags {
	ES_SPLITTER_VERTICAL = 0
	ES_SPLITTER_HORIZONTAL = bit 0
};

inttype EsListViewFlags uint64_t EsElementFlags {
	ES_LIST_VIEW_HORIZONTAL = bit 0 // Layout horizontally instead of vertically.
	ES_LIST_VIEW_VARIABLE_SIZE = bit 1 // Each item can be a different size. You need to respond to the LIST_VIEW_MEASURE_ITEM message. The size of items cannot depend on the size of the parent.
	ES_LIST_VIEW_TILED = bit 2 // Multiple items per band. Incompatible with variable size items and columns mode.
	ES_LIST_VIEW_SINGLE_SELECT = bit 3 // One item can be selected. By default, selections are disabled.
	ES_LIST_VIEW_MULTI_SELECT = bit 4 // Multiple items can be selected.
	ES_LIST_VIEW_CHOICE_SELECT = bit 5 // Exactly one item is always selected. Dragging on the list view causes the selection to 'slide' between items.
	ES_LIST_VIEW_COLUMNS = bit 6 // Display a column header and let items have multiple values. Incompatible with horizontal and tiled layouts.
	ES_LIST_VIEW_FIXED_ITEMS = bit 7 // Use the fixed item API rather than the callback API.
	ES_LIST_VIEW_CENTER_TILES = bit 8 // Center tiled items.
};

inttype EsListViewGroupFlags uint32_t none {
	ES_LIST_VIEW_GROUP_HAS_HEADER = bit 0 // The first item in the group is a header.
	ES_LIST_VIEW_GROUP_HAS_FOOTER = bit 1 // The last item in the group is a footer.
	ES_LIST_VIEW_GROUP_INDENT = bit 2 // Indent the group's items (excluding the header and footer).
	ES_LIST_VIEW_GROUP_COLLAPSABLE = bit 3 // The group can be collapsed.
};

inttype EsMenuFlags uint32_t none {
	ES_MENU_AT_CURSOR = bit 0
	ES_MENU_MAXIMUM_HEIGHT = bit 1
};

inttype EsFontFlags uint8_t none {
	ES_FONT_ITALIC = bit 0
};

inttype EsTextFigures uint8_t none {
	ES_TEXT_FIGURE_DEFAULT = 0
	ES_TEXT_FIGURE_OLD     = 1
	ES_TEXT_FIGURE_TABULAR = 2
};

inttype EsTextDecorations uint8_t none {
	ES_TEXT_DECORATION_UNDERLINE = bit 0
	ES_TEXT_DECORATION_STRIKE_THROUGH = bit 1
};

inttype EsTextDisplayFlags uint64_t EsElementFlags {
	ES_TEXT_DISPLAY_RICH_TEXT = bit 0
	ES_TEXT_DISPLAY_PREFORMATTED = bit 1 // Prevents trimming of trailing/leading whitespace.
	ES_TEXT_DISPLAY_NO_FONT_SUBSTITUTION = bit 2
};

inttype EsListDisplayFlags uint64_t EsElementFlags {
	// First 8 bits reserved for the marker type (see below).
	ES_LIST_DISPLAY_BULLETED = 0
	ES_LIST_DISPLAY_NUMBERED = 1
	ES_LIST_DISPLAY_LOWER_ALPHA = 2
	ES_LIST_DISPLAY_CUSTOM_MARKER = 0xFF // Sends ES_MSG_LIST_DISPLAY_GET_MARKER.
};
define ES_LIST_DISPLAY_MARKER_TYPE_MASK (0xFF << 0)

inttype EsImageDisplayFlags uint64_t EsElementFlags {
	ES_IMAGE_DISPLAY_DECODE_WHEN_NEEDED = bit 0 // The image is only kept in its decoded state when the display is on-screen.
	ES_IMAGE_DISPLAY_MANUAL_SIZE = bit 1 // The display will be manually sized; its size does not depend on the loaded image.
	ES_IMAGE_DISPLAY_FULLY_OPAQUE = bit 2 // The loaded image will always be fully opaque.
};

// Mask bits for EsThemeMetrics:
inttype EsThemeMetricsMask uint64_t none {
	ES_THEME_METRICS_INSETS = bit 0
	ES_THEME_METRICS_CLIP_INSETS = bit 1
	ES_THEME_METRICS_CLIP_ENABLED = bit 2
	ES_THEME_METRICS_CURSOR = bit 3
	ES_THEME_METRICS_PREFERRED_WIDTH = bit 4
	ES_THEME_METRICS_PREFERRED_HEIGHT = bit 5
	ES_THEME_METRICS_MINIMUM_WIDTH = bit 6
	ES_THEME_METRICS_MINIMUM_HEIGHT = bit 7
	ES_THEME_METRICS_MAXIMUM_WIDTH = bit 8
	ES_THEME_METRICS_MAXIMUM_HEIGHT = bit 9
	ES_THEME_METRICS_GAP_MAJOR = bit 10
	ES_THEME_METRICS_GAP_MINOR = bit 11
	ES_THEME_METRICS_GAP_WRAP = bit 12
	ES_THEME_METRICS_TEXT_COLOR = bit 13
	ES_THEME_METRICS_SELECTED_BACKGROUND = bit 14
	ES_THEME_METRICS_SELECTED_TEXT = bit 15
	ES_THEME_METRICS_ICON_COLOR = bit 16
	ES_THEME_METRICS_TEXT_ALIGN = bit 17
	ES_THEME_METRICS_TEXT_SIZE = bit 18
	ES_THEME_METRICS_FONT_FAMILY = bit 19
	ES_THEME_METRICS_FONT_WEIGHT = bit 20
	ES_THEME_METRICS_ICON_SIZE = bit 21
	ES_THEME_METRICS_IS_ITALIC = bit 22
	ES_THEME_METRICS_LAYOUT_VERTICAL = bit 23
	ES_THEME_METRICS_TEXT_FIGURES = bit 24
};

inttype EsTextboxMoveCaretRelativeFlags uint32_t none {
	ES_TEXTBOX_MOVE_CARET_SINGLE = 2
	ES_TEXTBOX_MOVE_CARET_WORD = 3
	ES_TEXTBOX_MOVE_CARET_LINE = 4
	ES_TEXTBOX_MOVE_CARET_VERTICAL = 5
	ES_TEXTBOX_MOVE_CARET_ALL = 6
	ES_TEXTBOX_MOVE_CARET_FIRST_ONLY = bit 8
	ES_TEXTBOX_MOVE_CARET_SECOND_ONLY = bit 9
	ES_TEXTBOX_MOVE_CARET_BACKWARDS = bit 10
	ES_TEXTBOX_MOVE_CARET_STRONG_WHITESPACE = bit 11
};

inttype EsConnectionOpenFlags uint32_t none {
	ES_CONNECTION_OPEN_WAIT = bit 0
};

inttype EsFileControlFlags uint32_t none {
	ES_FILE_CONTROL_FLUSH = bit 0
};

inttype EsElementUpdateContentFlags uint32_t none {
	ES_ELEMENT_UPDATE_CONTENT_WIDTH = bit 0
	ES_ELEMENT_UPDATE_CONTENT_HEIGHT = bit 1
};

inttype EsDialogShowFlags uint32_t none {
	ES_DIALOG_ALERT_OK_BUTTON = bit 0
};

inttype EsMemoryReserveFlags uint32_t none {
	ES_MEMORY_RESERVE_COMMIT_ALL = bit 0
};

inttype EsPanelSwitchToFlags uint32_t none {
	ES_PANEL_SWITCHER_DESTROY_PREVIOUS_AFTER_TRANSITION = bit 0
};

inttype EsElementTransitionFlags uint32_t none {
	ES_ELEMENT_TRANSITION_ENTRANCE = bit 0
	ES_ELEMENT_TRANSITION_EXIT = bit 1
	ES_ELEMENT_TRANSITION_HIDE_AFTER_COMPLETE = bit 2
};

inttype EsSyntaxHighlightingLanguage uint32_t none {
	ES_SYNTAX_HIGHLIGHTING_LANGUAGE_C      = 1
	ES_SYNTAX_HIGHLIGHTING_LANGUAGE_INI    = 2
	ES_SYNTAX_HIGHLIGHTING_LANGUAGE_SCRIPT = 3
};

inttype EsDrawLineFlags uint32_t none {
	ES_DRAW_LINE_CAP_ROUND  = bit 0
	ES_DRAW_LINE_CAP_SQUARE = bit 1
};

inttype EsDriveType uint8_t none {
	ES_DRIVE_TYPE_OTHER            = 0
	ES_DRIVE_TYPE_HDD              = 1
	ES_DRIVE_TYPE_SSD              = 2
	ES_DRIVE_TYPE_CDROM            = 3
	ES_DRIVE_TYPE_USB_MASS_STORAGE = 4
};

inttype EsElementFocusFlags uint32_t none {
	ES_ELEMENT_FOCUS_ENSURE_VISIBLE = bit 0
	ES_ELEMENT_FOCUS_FROM_KEYBOARD = bit 1
	ES_ELEMENT_FOCUS_ONLY_IF_NO_FOCUSED_ELEMENT = bit 2
};

inttype EsApplicationStartupRequestFlags uint32_t none {
	ES_APPLICATION_STARTUP_BACKGROUND_SERVICE = bit 0
	ES_APPLICATION_STARTUP_IN_SAME_CONTAINER = bit 1
	ES_APPLICATION_STARTUP_NO_DOCUMENT = bit 2 // The file path given in EsApplicationStartupRequest should be passed directly to the application, and should not be used to open a document.
};

inttype EsListViewInlineTextboxFlags uint32_t none {
	ES_LIST_VIEW_INLINE_TEXTBOX_COPY_EXISTING_TEXT = bit 0
	ES_LIST_VIEW_INLINE_TEXTBOX_REJECT_EDIT_IF_FOCUS_LOST = bit 1
};

inttype EsKeyboardModifiers uint8_t none {
	ES_MODIFIER_CTRL = bit 0
	ES_MODIFIER_SHIFT = bit 1
	ES_MODIFIER_ALT = bit 2
	ES_MODIFIER_FLAG = bit 3
	ES_MODIFIER_ALT_GR = bit 4
};

inttype EsProcessCreationFlags uint32_t none {
	ES_PROCESS_CREATE_PAUSED = bit 0
};

inttype EsVolumeFlags uint32_t none {
	ES_VOLUME_READ_ONLY = bit 0
};

inttype EsPathMoveFlags uint32_t none {
	// Copy and delete the file if a direct move is not possible (e.g. the files are on different volumes).
	ES_PATH_MOVE_ALLOW_COPY_AND_DELETE = bit 0
};

inttype EsClipboardDataFlags uint32_t none {
	// Only perform the deletion after pasting; often implemented as a move (e.g. files).
	ES_CLIPBOARD_ADD_LAZY_CUT = bit 0
};

inttype EsScrollViewMode uint8_t none {
	ES_SCROLL_MODE_NONE   = 0 // No scrolling takes place on this axis.
	ES_SCROLL_MODE_HIDDEN = 1 // Scrolling takes place, but there is no visible scrollbar.
	ES_SCROLL_MODE_FIXED  = 2 // The scrollbar is always visible.
	ES_SCROLL_MODE_AUTO   = 3 // The scrollbar is only visible if the content is larger than the viewport.
};
// Scroll view flags.
define ES_SCROLL_X_DRAG (1 << 0)
define ES_SCROLL_Y_DRAG (1 << 1)
private define ES_SCROLL_MANUAL (1 << 2) // The parent is responsible for updating the position of the scroll bars.

inttype EsSubsystemID uint8_t none {
	ES_SUBSYSTEM_ID_NATIVE = 0
	ES_SUBSYSTEM_ID_POSIX  = 1
};

inttype EsListViewChooseItemSource uint8_t none {
	ES_LIST_VIEW_CHOOSE_ITEM_OTHER        = 1
	ES_LIST_VIEW_CHOOSE_ITEM_ENTER        = 2
	ES_LIST_VIEW_CHOOSE_ITEM_DOUBLE_CLICK = 3
	ES_LIST_VIEW_CHOOSE_ITEM_MIDDLE_CLICK = 4
};

inttype EsCanvasPaneFlags uint64_t EsElementFlags {
	ES_CANVAS_PANE_SHOW_SHADOW = bit 0
};

inttype EsSliderFlags uint64_t none {
};

inttype EsSpacerFlags uint64_t none {
};

inttype EsIconDisplayFlags uint64_t none {
};

inttype EsAnnouncementFlags uint64_t none {
};

include desktop/icons.header

inttype EsFatalError enum none {
	ES_FATAL_ERROR_ABORT
	ES_FATAL_ERROR_INCORRECT_FILE_ACCESS
	ES_FATAL_ERROR_INCORRECT_NODE_TYPE
	ES_FATAL_ERROR_INSUFFICIENT_PERMISSIONS
	ES_FATAL_ERROR_INVALID_BUFFER
	ES_FATAL_ERROR_INVALID_HANDLE
	ES_FATAL_ERROR_INVALID_MEMORY_REGION
	ES_FATAL_ERROR_OUT_OF_RANGE // A parameter exceeds a limit, or is not a valid choice from an enumeration.
	ES_FATAL_ERROR_PROCESSOR_EXCEPTION
	ES_FATAL_ERROR_RECURSIVE_BATCH
	ES_FATAL_ERROR_UNKNOWN_SYSCALL
	ES_FATAL_ERROR_COUNT
}

private inttype EsSyscallType enum none {
	// Memory.

	ES_SYSCALL_MEMORY_ALLOCATE
	ES_SYSCALL_MEMORY_FREE
	ES_SYSCALL_MEMORY_MAP_OBJECT
	ES_SYSCALL_MEMORY_COMMIT
	ES_SYSCALL_MEMORY_FAULT_RANGE
	ES_SYSCALL_MEMORY_GET_AVAILABLE

	// Processing.

	ES_SYSCALL_EVENT_CREATE
	ES_SYSCALL_EVENT_RESET
	ES_SYSCALL_EVENT_SET
	ES_SYSCALL_PROCESS_CRASH
	ES_SYSCALL_PROCESS_CREATE
	ES_SYSCALL_PROCESS_GET_STATE
	ES_SYSCALL_PROCESS_GET_STATUS
	ES_SYSCALL_PROCESS_GET_TLS
	ES_SYSCALL_PROCESS_OPEN
	ES_SYSCALL_PROCESS_PAUSE
	ES_SYSCALL_PROCESS_TERMINATE
	ES_SYSCALL_SLEEP
	ES_SYSCALL_THREAD_CREATE
	ES_SYSCALL_THREAD_GET_ID
	ES_SYSCALL_THREAD_SET_TLS
	ES_SYSCALL_THREAD_SET_TIMER_ADJUST_ADDRESS
	ES_SYSCALL_THREAD_STACK_SIZE
	ES_SYSCALL_THREAD_TERMINATE
	ES_SYSCALL_WAIT
	ES_SYSCALL_YIELD_SCHEDULER

	// Windowing.

	ES_SYSCALL_MESSAGE_GET
	ES_SYSCALL_MESSAGE_POST
	ES_SYSCALL_MESSAGE_WAIT

	ES_SYSCALL_CURSOR_POSITION_GET
	ES_SYSCALL_CURSOR_POSITION_SET
	ES_SYSCALL_CURSOR_PROPERTIES_SET
	ES_SYSCALL_GAME_CONTROLLER_STATE_POLL
	ES_SYSCALL_EYEDROP_START

	ES_SYSCALL_SCREEN_WORK_AREA_SET
	ES_SYSCALL_SCREEN_WORK_AREA_GET
	ES_SYSCALL_SCREEN_BOUNDS_GET
	ES_SYSCALL_SCREEN_GET_BITS
	ES_SYSCALL_SCREEN_FORCE_UPDATE

	ES_SYSCALL_WINDOW_CREATE
	ES_SYSCALL_WINDOW_CLOSE
	ES_SYSCALL_WINDOW_REDRAW
	ES_SYSCALL_WINDOW_MOVE
	ES_SYSCALL_WINDOW_TRANSFER_PRESS
	ES_SYSCALL_WINDOW_FIND_BY_POINT
	ES_SYSCALL_WINDOW_GET_ID
	ES_SYSCALL_WINDOW_GET_BOUNDS
	ES_SYSCALL_WINDOW_SET_BITS
	ES_SYSCALL_WINDOW_SET_CURSOR
	ES_SYSCALL_WINDOW_SET_PROPERTY

	// IO.

	ES_SYSCALL_NODE_OPEN
	ES_SYSCALL_NODE_DELETE
	ES_SYSCALL_NODE_MOVE
	ES_SYSCALL_FILE_READ_SYNC
	ES_SYSCALL_FILE_WRITE_SYNC
	ES_SYSCALL_FILE_RESIZE
	ES_SYSCALL_FILE_GET_SIZE
	ES_SYSCALL_FILE_CONTROL
	ES_SYSCALL_DIRECTORY_ENUMERATE
	ES_SYSCALL_VOLUME_GET_INFORMATION
	ES_SYSCALL_DEVICE_CONTROL

	// Networking.

	ES_SYSCALL_DOMAIN_NAME_RESOLVE
	ES_SYSCALL_ECHO_REQUEST
	ES_SYSCALL_CONNECTION_OPEN
	ES_SYSCALL_CONNECTION_POLL
	ES_SYSCALL_CONNECTION_NOTIFY

	// IPC.

	ES_SYSCALL_CONSTANT_BUFFER_READ
	ES_SYSCALL_CONSTANT_BUFFER_CREATE
	ES_SYSCALL_PIPE_CREATE
	ES_SYSCALL_PIPE_WRITE
	ES_SYSCALL_PIPE_READ

	// Misc.

	ES_SYSCALL_HANDLE_CLOSE
	ES_SYSCALL_HANDLE_SHARE
	ES_SYSCALL_BATCH
	ES_SYSCALL_DEBUG_COMMAND
	ES_SYSCALL_POSIX
	ES_SYSCALL_PRINT
	ES_SYSCALL_SHUTDOWN
	ES_SYSCALL_SYSTEM_TAKE_SNAPSHOT
	ES_SYSCALL_PROCESSOR_COUNT

	// End.

	ES_SYSCALL_COUNT
}

inttype EsMessageType enum none {
	ES_MSG_INVALID				= 0x0000
		
	// Window manager messages (don't rearrange; see SendMessageToWindow in kernel/window_manager.cpp):
	ES_MSG_WM_START				= 0x1000
	ES_MSG_MOUSE_MOVED 			= 0x1001
	ES_MSG_WINDOW_ACTIVATED			= 0x1002
	ES_MSG_WINDOW_DEACTIVATED		= 0x1003
	ES_MSG_WINDOW_DESTROYED 		= 0x1004
	ES_MSG_MOUSE_EXIT			= 0x1006 
	ES_MSG_WINDOW_RESIZED			= 0x1007
	ES_MSG_MOUSE_LEFT_DOWN 			= 0x1008	// Return ES_REJECTED to prevent taking focus, even if ES_ELEMENT_FOCUSABLE is set. Propagates.
	ES_MSG_MOUSE_LEFT_UP 			= 0x1009	// Propagates.
	ES_MSG_MOUSE_RIGHT_DOWN 		= 0x100A	// Propagates.
	ES_MSG_MOUSE_RIGHT_UP 			= 0x100B	// Propagates.
	ES_MSG_MOUSE_MIDDLE_DOWN 		= 0x100C	// Propagates.
	ES_MSG_MOUSE_MIDDLE_UP 			= 0x100D 	// Propagates.
	ES_MSG_KEY_DOWN				= 0x100E	// Propagates to ancestors if unhandled.
	ES_MSG_KEY_UP				= 0x100F
	ES_MSG_UPDATE_WINDOW			= 0x1010
	ES_MSG_SCROLL_WHEEL			= 0x1011
	ES_MSG_WM_END				= 0x13FF

	// Internal GUI messages:				// None of these should be sent directly.
	ES_MSG_PAINT				= 0x2000	// Paint the element using the painter specified in the message.
	ES_MSG_PAINT_BACKGROUND			= 0x2001	// Paint the element's background. Sent before ES_MSG_PAINT. 
								// If unhandled, the background is drawn using the default settings. 
								// The width/height parameters of EsPainter may be larger than expected - this includes the 'non-client' area.
	ES_MSG_GET_CURSOR			= 0x2003	// Get the cursor for the element.
	ES_MSG_ANIMATE				= 0x2004	// Animate the element. Returns the number of microseconds to wait for the next frame, 
								// or whether the animation is complete.
	ES_MSG_Z_ORDER				= 0x2005	// Get the child of an element based on its Z-order.
	ES_MSG_DESTROY				= 0x2006	// The element has been marked to be destroyed. Free any resources allocated. 
								// Sent after the parent receives its ES_MSG_REMOVE_CHILD message.
	ES_MSG_GET_WIDTH			= 0x2007	// Measure the element's width. If known, the height is specified.
	ES_MSG_GET_HEIGHT			= 0x2008	// Measure the element's height. If known, the width is specified.
	ES_MSG_LAYOUT				= 0x2009	// The size of the element has been updated. Layout the element's children.
	ES_MSG_ENSURE_VISIBLE			= 0x200A	// Center the specified child (where possible) in your scrolled viewport.
	ES_MSG_ADD_CHILD			= 0x200B	// An element has been created with this element as its parent.
	ES_MSG_REMOVE_CHILD			= 0x200C	// An element has been destroyed with this element as its parent. 
								// Sent before the child receives its ES_MSG_DESTROY message. 
								// It will be removed from the `children` later (but before the next ES_MSG_LAYOUT message is received).
	ES_MSG_PRE_ADD_CHILD			= 0x200D	// An element has been created with this element as its parent, but is not yet added to the parent.
	ES_MSG_HIT_TEST				= 0x200E	// For non-rectangular elements: test whether a pixel should be considered inside the element. Set response to ES_HANDLED.
	ES_MSG_KEY_TYPED			= 0x2011	// Sent to the focused element when a key is pressed. 
								// Only if ES_HANDLED is returned the message will not propagate; 
								// this allows messageUser to block input processing by returning ES_REJECTED.
	ES_MSG_SCROLL_X				= 0x2012	// The element has been horizontally scrolled.
	ES_MSG_SCROLL_Y				= 0x2013	// The element has been vertically scrolled.
	ES_MSG_STRONG_FOCUS_END			= 0x2014	// Sent once when the user 'clicks off' the element, even if a new element was not necessarily focused. Not sent when destroying the element!
	ES_MSG_BEFORE_Z_ORDER			= 0x2015	// Sent before a batch of Z_ORDER messages.
	ES_MSG_AFTER_Z_ORDER			= 0x2016	// Sent after a batch of Z_ORDER messages.
	ES_MSG_PAINT_CHILDREN			= 0x2017	// Paint the element's children. Useful for animations, with EsPaintTargetTake/Return.
	ES_MSG_DESTROY_CONTENTS			= 0x2018	// Sent after EsElementDestroyContents is called.
	ES_MSG_GET_INSPECTOR_INFORMATION	= 0x2019	// Get a string containing information about the element to display in the inspector.
	ES_MSG_NOT_VISIBLE			= 0x2020	// Sent to elements in the check visible list when they move off-screen.
	ES_MSG_GET_CHILD_STYLE_VARIANT		= 0x2021	// Allows the parent of an element to customize its default style.
	ES_MSG_PAINT_ICON			= 0x2022	// Sent during EsDrawContent.
	ES_MSG_MOUSE_LEFT_CLICK			= 0x2023	// Indicates the element has been "clicked" (might be different for other input devices).
	ES_MSG_MOUSE_RIGHT_CLICK		= 0x2024	// Right click, similar to LEFT_CLICK above.
	ES_MSG_MOUSE_MIDDLE_CLICK		= 0x2025	// Middle click, similar to LEFT_CLICK above.
	ES_MSG_MOUSE_LEFT_DRAG			= 0x2026	// Left button is pressed and the mouse is moving. 
								// Only starts being sent after a threshold is reached. 
								// This will NOT be sent if the element did not handle LEFT_DOWN.
	ES_MSG_MOUSE_RIGHT_DRAG			= 0x2027	// Similar to LEFT_DRAG above, but for the right button. 
	ES_MSG_MOUSE_MIDDLE_DRAG		= 0x2028	// Similar to LEFT_DRAG above, but for the middle button. 
	ES_MSG_GET_ACCESS_KEY_HINT_BOUNDS	= 0x2029	// Get the bounds to display an access key hint.
	ES_MSG_UI_SCALE_CHANGED			= 0x202A	// The UI scale has changed.
	ES_MSG_TRANSITION_COMPLETE		= 0x202B	// The transition started with EsElementStartTransition completed.
	ES_MSG_PAINT_FOREGROUND			= 0x202C	// Paint the element's foreground. Sent after the children are painted.
								// The width/height parameters of EsPainter may be larger than expected - this includes the 'non-client' area.
	ES_MSG_PRIMARY_CLIPBOARD_UPDATED	= 0x202D	// Send to the focused element when the contents of the primary clipboard is changes.
								// This message might be delayed if the window containing the element is inactive.

	// State change messages: (causes a style refresh)
	ES_MSG_STATE_CHANGE_MESSAGE_START	= 0x2080
	ES_MSG_HOVERED_START			= 0x2081	// Sent when the mouse starts hovering over an element.
	ES_MSG_HOVERED_END			= 0x2082	// Opposite of ES_MSG_HOVERED_START. Sent before ES_MSG_HOVERED_START is sent to the new hovered element. Not sent when destroying the element!
	ES_MSG_PRESSED_START			= 0x2083	// Sent when an element is pressed.
	ES_MSG_PRESSED_END			= 0x2084	// Opposite of ES_MSG_PRESSED_START. Not sent when destroying the element!
	ES_MSG_FOCUSED_START			= 0x2085	// Sent when an element is focused.
	ES_MSG_FOCUSED_END			= 0x2086	// Opposite of ES_MSG_FOCUSED_START. Not sent when destroying the element!
	ES_MSG_FOCUS_WITHIN_START		= 0x2087	// Sent when an element is focused.
	ES_MSG_FOCUS_WITHIN_END			= 0x2088	// Opposite of ES_MSG_FOCUSED_START. Not sent when destroying the element!
	ES_MSG_STATE_CHANGE_MESSAGE_END		= 0x20FF

	// Element messages:
	ES_MSG_SCROLLBAR_MOVED			= 0x3000	// The scrollbar has been moved.
	ES_MSG_CHECK_UPDATED			= 0x3001	// Button's check state has changed. See message->checkState.
	ES_MSG_RADIO_GROUP_UPDATED		= 0x3002	// Sent to all siblings of a radiobox when it is checked, so they can uncheck themselves.
	ES_MSG_COLOR_CHANGED			= 0x3003	// Color well's color has changed. See message->colorChanged.
	ES_MSG_LIST_DISPLAY_GET_MARKER		= 0x3004	// Get the string for a marker in an EsListDisplay. See message->getContent.
	ES_MSG_SLIDER_MOVED			= 0x3006	// The slider has been moved.

	// Undo item messages:
	ES_MSG_UNDO_CANCEL			= 0x4D00
	ES_MSG_UNDO_INVOKE			= 0x4D01
	ES_MSG_UNDO_TO_STRING			= 0x4D02

	// File Manager messages:
	ES_MSG_FILE_MANAGER_FILE_MODIFIED	= 0x5100
	ES_MSG_FILE_MANAGER_PATH_MOVED		= 0x5101
	ES_MSG_FILE_MANAGER_DOCUMENT_UPDATE	= 0x5102	// The managed list of open documents has been updated.

	// Textbox messages:
	ES_MSG_TEXTBOX_UPDATED			= 0x5200
	ES_MSG_TEXTBOX_EDIT_START		= 0x5201 	// Set ES_TEXTBOX_EDIT_BASED to receive.
	ES_MSG_TEXTBOX_EDIT_END			= 0x5202 	// Set ES_TEXTBOX_EDIT_BASED to receive.
	ES_MSG_TEXTBOX_NUMBER_DRAG_START	= 0x5203 	// For EsTextboxUseNumberOverlay.
	ES_MSG_TEXTBOX_NUMBER_DRAG_END		= 0x5204 	// For EsTextboxUseNumberOverlay.
	ES_MSG_TEXTBOX_NUMBER_DRAG_DELTA	= 0x5205 	// For EsTextboxUseNumberOverlay.
	ES_MSG_TEXTBOX_NUMBER_UPDATED		= 0x5206 	// For EsTextboxUseNumberOverlay with defaultBehaviour=true.
	ES_MSG_TEXTBOX_GET_BREADCRUMB		= 0x5207 	// For EsTextboxUseBreadcrumbOverlay.
	ES_MSG_TEXTBOX_ACTIVATE_BREADCRUMB	= 0x5208 	// For EsTextboxUseBreadcrumbOverlay.

	// List view messages:
	ES_MSG_LIST_VIEW_FIND_INDEX		= 0x5301
	ES_MSG_LIST_VIEW_MEASURE_RANGE		= 0x5302
	ES_MSG_LIST_VIEW_MEASURE_ITEM		= 0x5303
	ES_MSG_LIST_VIEW_CREATE_ITEM		= 0x5304
	ES_MSG_LIST_VIEW_GET_CONTENT		= 0x5305
	ES_MSG_LIST_VIEW_GET_INDENT		= 0x5306
	ES_MSG_LIST_VIEW_FIND_POSITION		= 0x5307
	ES_MSG_LIST_VIEW_IS_SELECTED		= 0x5308
	ES_MSG_LIST_VIEW_SELECT			= 0x5309
	ES_MSG_LIST_VIEW_SELECT_RANGE		= 0x530A
	ES_MSG_LIST_VIEW_CHOOSE_ITEM		= 0x530B
	ES_MSG_LIST_VIEW_SEARCH			= 0x530C
	ES_MSG_LIST_VIEW_CONTEXT_MENU		= 0x530D
	ES_MSG_LIST_VIEW_COLUMN_MENU		= 0x530E
	ES_MSG_LIST_VIEW_GET_SUMMARY		= 0x530F
	ES_MSG_LIST_VIEW_GET_COLUMN_SORT	= 0x5310
	ES_MSG_LIST_VIEW_GET_ITEM_DATA		= 0x5311

	// Reorder list messages:
	ES_MSG_REORDER_ITEM_TEST		= 0x5400
	ES_MSG_REORDER_ITEM_MOVED		= 0x5401

	// Application messages:
	ES_MSG_APPLICATION_EXIT			= 0x6001
	ES_MSG_INSTANCE_CREATE			= 0x6002
	ES_MSG_DEVICE_CONNECTED			= 0x6003
	ES_MSG_DEVICE_DISCONNECTED		= 0x6004

	// Instance messages:
	ES_MSG_INSTANCE_OPEN			= 0x6800
	ES_MSG_INSTANCE_SAVE			= 0x6801
	ES_MSG_INSTANCE_DESTROY			= 0x6802
	ES_MSG_INSTANCE_CLOSE			= 0x6803

	// Messages for internal use by the system:
	ES_MSG_SYSTEM_START			= 0x7000
	ES_MSG_SYSTEM_END			= 0x7FFF

	// User messages:
	ES_MSG_USER_START			= 0x8000
	ES_MSG_USER_END				= 0xBFFF
}

inttype EsCursorStyle enum none {
	ES_CURSOR_NORMAL 
	ES_CURSOR_TEXT 
	ES_CURSOR_RESIZE_VERTICAL 
	ES_CURSOR_RESIZE_HORIZONTAL
	ES_CURSOR_RESIZE_DIAGONAL_1 // '/'
	ES_CURSOR_RESIZE_DIAGONAL_2 // '\'
	ES_CURSOR_SPLIT_VERTICAL
	ES_CURSOR_SPLIT_HORIZONTAL
	ES_CURSOR_HAND_HOVER
	ES_CURSOR_HAND_DRAG
	ES_CURSOR_HAND_POINT
	ES_CURSOR_SCROLL_UP_LEFT
	ES_CURSOR_SCROLL_UP
	ES_CURSOR_SCROLL_UP_RIGHT
	ES_CURSOR_SCROLL_LEFT
	ES_CURSOR_SCROLL_CENTER
	ES_CURSOR_SCROLL_RIGHT
	ES_CURSOR_SCROLL_DOWN_LEFT
	ES_CURSOR_SCROLL_DOWN
	ES_CURSOR_SCROLL_DOWN_RIGHT
	ES_CURSOR_SELECT_LINES
	ES_CURSOR_DROP_TEXT
	ES_CURSOR_CROSS_HAIR_PICK
	ES_CURSOR_CROSS_HAIR_RESIZE
	ES_CURSOR_MOVE_HOVER
	ES_CURSOR_MOVE_DRAG
	ES_CURSOR_ROTATE_HOVER
	ES_CURSOR_ROTATE_DRAG
	ES_CURSOR_BLANK
	ES_CURSOR_COUNT
}

inttype EsWindowStyle enum none {
	ES_WINDOW_NORMAL
	ES_WINDOW_CONTAINER
	ES_WINDOW_MENU
	ES_WINDOW_TIP
	ES_WINDOW_PLAIN
	ES_WINDOW_INSPECTOR
}

inttype EsCheckState enum none {
	ES_CHECK_UNCHECKED = 0
	ES_CHECK_CHECKED = 1
	ES_CHECK_INDETERMINATE = 2
}

inttype EsTransitionType enum none {
	ES_TRANSITION_NONE
	ES_TRANSITION_SLIDE_UP
	ES_TRANSITION_SLIDE_DOWN
	ES_TRANSITION_COVER_UP
	ES_TRANSITION_COVER_DOWN
	ES_TRANSITION_SQUISH_UP
	ES_TRANSITION_SQUISH_DOWN
	ES_TRANSITION_ZOOM_OUT
	ES_TRANSITION_ZOOM_IN
	ES_TRANSITION_ZOOM_OUT_LIGHT
	ES_TRANSITION_ZOOM_IN_LIGHT
	ES_TRANSITION_REVEAL_UP
	ES_TRANSITION_REVEAL_DOWN
	ES_TRANSITION_FADE_IN
	ES_TRANSITION_FADE_OUT
	ES_TRANSITION_FADE
	ES_TRANSITION_FADE_VIA_TRANSPARENT
	ES_TRANSITION_SLIDE_UP_OVER
	ES_TRANSITION_SLIDE_DOWN_OVER
	ES_TRANSITION_SLIDE_UP_UNDER
	ES_TRANSITION_SLIDE_DOWN_UNDER
}

inttype EsMemoryProtection enum none {
	ES_MEMORY_PROTECTION_READ_ONLY
	ES_MEMORY_PROTECTION_READ_WRITE
	ES_MEMORY_PROTECTION_EXECUTABLE
}

inttype EsClipboard enum none {
	ES_CLIPBOARD_PRIMARY
}

inttype EsDeviceType enum none {
	ES_DEVICE_OTHER
	ES_DEVICE_CONTROLLER
	ES_DEVICE_FILE_SYSTEM
	ES_DEVICE_GRAPHICS_TARGET
	ES_DEVICE_BLOCK
	ES_DEVICE_AUDIO
	ES_DEVICE_KEYBOARD
	ES_DEVICE_MOUSE
	ES_DEVICE_GAME_CONTROLLER
	ES_DEVICE_NETWORK_CARD
	ES_DEVICE_USB
	ES_DEVICE_PCI_FUNCTION
	ES_DEVICE_CLOCK
}

inttype EsClipboardFormat enum none {
	ES_CLIPBOARD_FORMAT_INVALID
	ES_CLIPBOARD_FORMAT_TEXT
	ES_CLIPBOARD_FORMAT_PATH_LIST
}

inttype EsDeviceControlType enum none {
	ES_DEVICE_CONTROL_BLOCK_GET_INFORMATION = 0x1001
	ES_DEVICE_CONTROL_BLOCK_READ            = 0x1002
	ES_DEVICE_CONTROL_BLOCK_WRITE           = 0x1003
	ES_DEVICE_CONTROL_BLOCK_DETECT_FS       = 0x1004 // Detect file systems. All existing file systems must have been unmounted.

	ES_DEVICE_CONTROL_CLOCK_READ            = 0x2001

	ES_DEVICE_CONTROL_FS_IS_BOOT            = 0x3001
}

function_pointer int EsElementCallback(struct EsElement *element, struct EsMessage *message);
function_pointer int EsInstanceCallback(ES_INSTANCE_TYPE *instance, struct EsMessage *message);

struct EsBuffer {
	union { const uint8_t *in; uint8_t *out; };
	size_t position, bytes;
	void *context;
	EsFileStore *fileStore;
	bool error, canGrow;
} @opaque();

struct EsElementPublic {
	EsElementCallback messageUser;
	EsCString cName; 
	EsGeneric userData; 
	char accessKey; // Upper-case.

	// These fields are read-only!
	EsWindow *window;
	ES_INSTANCE_TYPE *instance;
	EsElementFlags flags; // Bits 0-31: specific to the type of element; bits 32-63: common to all elements.
} @opaque();

private struct EsBatchCall {
	EsSyscallType index; 
	bool stopBatchIfError;
	union { uintptr_t argument0, returnValue; };
	uintptr_t argument1, argument2, argument3;
};

struct EsThreadInformation {
	EsHandle handle;
	EsObjectID tid;
};

struct EsProcessInformation {
	EsHandle handle;
	uintptr_t pid;
	EsThreadInformation mainThread;
};

struct EsUniqueIdentifier {
	// Don't mess with this structure, it's used in filesystems.
	uint8_t d[16];
};

struct EsFileInformation {
	EsHandle handle; 
	EsFileOffset size;
	EsError error;
};

struct EsDirectoryChild {
	char name[ES_MAX_DIRECTORY_CHILD_NAME_LENGTH];
	size_t nameBytes;
	EsNodeType type;
	EsFileOffsetDifference fileSize; // -1 if unsupported.
	EsFileOffsetDifference directoryChildren; // ES_DIRECTORY_CHILDREN_UNKNOWN if unsupported.
};

struct EsPoint {
	int32_t x;
	int32_t y;
};

struct EsRectangle {
	int32_t l; // Inclusive.
	int32_t r; // Exclusive.
	int32_t t; // Inclusive.
	int32_t b; // Exclusive.
};

struct EsSpinlock {
	volatile uint8_t state;
} @opaque();

struct EsMutex {
	EsHandle event;
	EsSpinlock spinlock;
	volatile uint8_t state;
	volatile uint32_t queued;
} @opaque();

struct EsCrashReason {
	EsFatalError errorCode;
	int32_t duringSystemCall;
};

struct EsProcessState {
	EsCrashReason crashReason;
	EsObjectID id;
	uint8_t executableState;
	EsProcessStateFlags flags;
};

struct EsPainter {
	EsRectangle clip;
	int32_t offsetX, offsetY, width, height;
	void *style;
	EsPaintTarget *target;
} @opaque();

struct EsDebuggerMessage {
	EsHandle process;
	EsCrashReason reason;
};

struct EsSnapshotProcessesItem {
	int64_t pid, memoryUsage, cpuTimeSlices, idleTimeSlices, handleCount, threadCount;
	char name[ES_SNAPSHOT_MAX_PROCESS_NAME_LENGTH];
	uint8_t nameBytes;
	bool isKernel;
};

struct EsSnapshotProcesses {
	size_t count;
	EsSnapshotProcessesItem processes[];
};

struct EsProcessCreateData {
	EsHandle systemData;
	EsHandle subsystemData;
	EsGeneric userData;
	EsSubsystemID subsystemID;
};

struct EsProcessStartupInformation {
	bool isDesktop, isBundle;
	uintptr_t applicationStartAddress;
	uintptr_t tlsImageStart;
	uintptr_t tlsImageBytes;
	uintptr_t tlsBytes; // All bytes after the image are to be zeroed.
	uintptr_t timeStampTicksPerMs;
	EsHandle globalDataRegion;
	EsProcessCreateData data;
};

struct EsProcessCreationArguments {
	EsHandle executable;
	const EsHandle *handles; // Duplicated.
	const uint32_t *handleModes; // The share arguments.
	size_t handleCount;
	EsProcessCreateData data;
	EsProcessCreationFlags flags;
	EsProcessPermissions permissions;
} @array_in(handles, handleCount) @array_in(handleModes, handleCount);

struct EsInstance {
	// Read-only variables.
	void *_private;
	EsWindow *window;
	EsUndoManager *undoManager;

	// Read-write.
	EsInstanceCallback callback;
} @opaque();

struct EsPanelBand {
	int preferredSize, minimumSize, maximumSize;
	int push, pull; // Similar to flex-grow and flex-shrink from CSS.
};

struct EsThemeMetrics {
	EsThemeMetricsMask mask;
	EsRectangle insets, clipInsets;
	bool clipEnabled;
	EsCursorStyle cursor;
	int32_t preferredWidth, preferredHeight;
	int32_t minimumWidth, minimumHeight;
	int32_t maximumWidth, maximumHeight;
	int32_t gapMajor, gapMinor, gapWrap;
	uint32_t textColor, selectedBackground, selectedText, iconColor;
	EsTextFlags textAlign;
	int32_t textSize, fontFamily, fontWeight, iconSize;
	EsTextFigures textFigures;
	bool isItalic, layoutVertical;
};

struct EsThemeAppearance {
	bool enabled;
	uint32_t backgroundColor;
	uint32_t borderColor;
	EsRectangle borderSize;
};

struct EsStyle {
	EsStyleID inherit; // Must be a built-in style.
	EsThemeMetrics metrics; // Unscaled!
	EsThemeAppearance appearance;
};

include desktop/styles.header

struct EsFont {
	EsFontFamily family;
	uint8_t weight;
	EsFontFlags flags;
};

struct EsTextStyle {
	// TODO Indicating RTL/vertical writing modes.
	// TODO Support for features.
	// TODO Support for variable fonts.

	EsFont font;
	uint16_t size, baselineOffset;

	int8_t tracking;
	uint8_t figures;
	bool alternateDirection;

	// Render properties:
	uint8_t blur;
	EsTextDecorations decorations;
	uint32_t color;
	uint32_t decorationsColor;
};

struct EsTextRun {
	EsTextStyle style;
	uint32_t offset;
};

struct EsTextPlanProperties {
	EsCString cLanguage;
	EsTextPlanFlags flags; 
	int maxLines; // Set to 0 for no limit.
};

struct EsTextSelection {
	ptrdiff_t caret0, caret1;
	bool hideCaret, snapCaretToInsets;
	uint32_t foreground, background;
};

struct EsCalculationValue {
	bool error;
	double number;
};

function_pointer void EsCommandCallback(ES_INSTANCE_TYPE *instance, EsElement *element, struct EsCommand *command);

struct EsCommand {
	EsElement **elements;
	EsCommandCallback callback;
	bool enabled, registered, allocated;
	EsCheckState check;
	uint32_t stableID;
	EsCString cKeyboardShortcut;
	EsGeneric data;
	STRING title;
} @opaque();

struct EsApplicationStartupRequest {
	int64_t id;
	STRING filePath; // Only contains the file name if the application does not have permission_all_files or the file is not on a file system.
	EsApplicationStartupRequestFlags flags;
};

private struct _EsApplicationStartupInformation {
	int64_t id;
	STRING filePath; // See comment in EsApplicationStartupRequest.
	EsWindow *targetWindow;
	uint32_t flags;
	int32_t data;
	EsHandle readHandle; 
	EsObjectID documentID;
	STRING containingFolder;
};

struct EsINIState {
	char *buffer, *sectionClass, *section, *key, *value;
	size_t bytes, sectionClassBytes, sectionBytes, keyBytes, valueBytes;
} @opaque();

struct EsAnalogInput {
	uint8_t x, y, z;
};

struct EsGameControllerState {
	EsObjectID id; 
	uint8_t buttonCount, analogCount; // Number of buttons and analog inputs.
	uint8_t directionalPad; // Directions given from 0-7, starting at up, going clockwise. 15 indicates unpressed.
	uint32_t buttons; // Bitset of pressed buttons.
	EsAnalogInput analog[8];
};

struct EsPCIDevice {
	uint32_t deviceID;
	uint8_t classCode, subclassCode, progIF;
	uint8_t bus, slot, function;
	uint8_t interruptPin, interruptLine;
	size_t baseAddressesSizes[6];
	uint32_t baseAddresses[6];
	char driverName[64];
	size_t driverNameBytes;
};

struct EsAddress {
	union {
		struct {
			uint32_t ipv4;
			uint16_t port;
		};

		uint8_t d[20];
	};
} @opaque();

struct EsConnection {
	EsAddress address;
	size_t receiveBufferBytes;
	size_t sendBufferBytes;

	uint8_t *receiveBuffer;
	uint8_t *sendBuffer;

	uintptr_t receiveWritePointer;
	uintptr_t sendReadPointer;
	bool open;
	EsError error;

	uintptr_t receiveReadPointer;
	uintptr_t sendWritePointer;

	EsHandle handle;
} @opaque();

struct EsFileMenuSettings {
};

struct EsInstanceClassEditorSettings {
	STRING newDocumentFileName; // The default file name to use when creating a new document.
	STRING newDocumentTitle; // The title to show in the file menu if the document has not been saved.
	uint32_t documentIconID;
};

struct EsInstanceClassViewerSettings {
};

private struct _EsNodeInformation {
	EsHandle handle; 
	EsFileOffset fileSize;
	EsFileOffsetDifference directoryChildren; 
	EsNodeType type;
};

struct EsVolumeInformation {
	char label[64];
	uint8_t labelBytes;
	EsDriveType driveType;
	EsVolumeFlags flags;
	EsObjectID id;
	EsFileOffset spaceTotal;
	EsFileOffset spaceUsed;
	EsUniqueIdentifier identifier;
	EsUniqueIdentifier installationIdentifier; // Currently only supported by EsFS.
};

// User interface messages.

struct EsMessageMouseMotion {
	int newPositionX;
	int newPositionY;
	int originalPositionX; // For MOUSE_DRAGGED only.
	int originalPositionY;
};

struct EsMessageMouseButton {
	int positionX;
	int positionY;
	uint8_t clickChainCount;
};

struct EsMessageKeyboard {
	uint16_t scancode; 
	EsKeyboardModifiers modifiers;
	bool repeat, numpad, numlock, single;
};

struct EsMessageWindowActivated {
	uint8_t leftModifiers, rightModifiers;
};

struct EsMessageScrollWheel {
	int32_t dx, dy;
};

struct EsMessageAnimate {
	int64_t deltaMs, waitMs;
	bool complete;
};

struct EsMessageLayout {
	bool sizeChanged;
};

struct EsMessageWindowResized {
	EsRectangle content;
	bool hidden;
};

struct EsMessageMeasure {
	int width, height;
	bool internalMeasurement; // Used by scroll panes; ignore.
};

struct EsMessageHitTest {
	int x, y;
	bool inside;
};

struct EsMessageZOrder {
	uintptr_t index;
	EsElement *child;
};

struct EsMessageBeforeZOrder {
	uintptr_t start, end, nonClient;
	EsRectangle clip;
};

struct EsMessageItemToString {
	EsGeneric item;
	STRING text;
};

struct EsMessageScroll {
	int scroll, previous;
};

struct EsMessageEnsureVisible {
	bool center; // If false, only center the element if it is partially obscured.
	EsElement *descendent;
};

// List view messages.

struct EsMessageIterateIndex {
	EsListViewIndex group;
	EsListViewIndex index;

	// FIND_INDEX and FIND_POSITION: (TODO Pass the reference item?)
	int64_t position;
};

struct EsMessageItemRange {
	EsListViewIndex group;
	EsListViewIndex firstIndex;
	uint64_t count;
	int64_t result;
};

struct EsMessageMeasureItem {
	EsListViewIndex group;
	EsListViewIndex index;
	int64_t result;
};

struct EsMessageCreateItem {
	EsListViewIndex group;
	EsListViewIndex index;
	EsElement *item;
};

struct EsMessageGetContent {
	EsListViewIndex index;
	EsListViewIndex group;
	EsBuffer *buffer;
	uint32_t icon;
	uint32_t drawContentFlags;
	uint32_t columnID;
	uint16_t activeColumnIndex;
};

struct EsMessageGetItemData {
	EsListViewIndex index;
	EsListViewIndex group;
	uint32_t columnID;
	uint16_t activeColumnIndex;
	uint32_t icon;

	union {
		struct { STRING s; };
		int64_t i;
		double d;
	};
} @opaque();

struct EsMessageGetIndent {
	EsListViewIndex group;
	EsListViewIndex index;
	uint8_t indent;
};

struct EsMessageSelectRange {
	EsListViewIndex fromIndex, toIndex;
	EsListViewIndex group; 
	bool select, toggle;
};

struct EsMessageSelectItem {
	EsListViewIndex group;
	EsListViewIndex index;
	bool isSelected;
};

struct EsMessageChooseItem {
	EsListViewIndex group;
	EsListViewIndex index;
	EsListViewChooseItemSource source;
};

struct EsMessageSearchItem {
	EsListViewIndex group;
	EsListViewIndex index;
	STRING query;
};

struct EsMessageFocus {
	uint32_t flags;
};

struct EsMessageColumnMenu {
	EsElement *source;
	uint32_t columnID;
	uint16_t activeColumnIndex;
};

struct EsMessageGetColumnSort {
	uint8_t index;
};

// Specific element messages.

struct EsMessageSliderMoved {
	double value, previous;
	bool inDrag;
};

struct EsMessageColorChanged {
	uint32_t newColor;
	bool pickerClosed;
};

struct EsMessageNumberDragDelta {
	int delta;
	int32_t hoverCharacter;
	bool fast;
};

struct EsMessageNumberUpdated {
	double delta;
	double newValue;
};

struct EsMessageGetBreadcrumb {
	uintptr_t index; // Set response to ES_REJECTED if this equals the number of breadcrumbs.
	EsBuffer *buffer;
	uint32_t icon;
};

struct EsMessageEndEdit {
	bool rejected, unchanged;
};

// Instance messages.

struct EsMessageInstanceOpen {
	EsFileStore *file;
	STRING nameOrPath; // See comment in EsApplicationStartupRequest.
	bool update;
};

struct EsMessageInstanceSave {
	EsFileStore *file;
	STRING nameOrPath; // See comment in EsApplicationStartupRequest.
};

// Internal system messages.

struct EsMessageProcessCrash {
	EsCrashReason reason;
	uintptr_t pid;
};

struct EsMessageEyedrop {
	uint32_t color;
	bool cancelled;
};

struct EsMessageCreateInstance {
	EsHandle window;
	EsHandle data;
	size_t dataBytes;
};

struct EsMessageTabOperation {
	EsObjectID id;
	EsHandle handle;
	union { size_t bytes; bool isSource; };
	EsError error;
} @opaque();

struct EsMessageDevice {
	EsObjectID id;
	EsHandle handle; // Not set in ES_MSG_DEVICE_DISCONNECTED. This handle is owned by the system, and is closed on receiving the disconnected message within EsMessageReceive.
	EsDeviceType type;
};

// Message structure.

struct EsMessageUser {
	EsGeneric context1, context2, context3, context4;
};

struct EsMessage {
	EsMessageType type;

	union {
		struct { uintptr_t _size[4]; } _size; // EsMessagePost supports messages at most 4 pointers in size.
		EsMessageUser user; // For application specific messages.

		// User interface messages:
		EsMessageMouseMotion mouseMoved;
		EsMessageMouseMotion mouseDragged;
		EsMessageMouseButton mouseDown;
		EsMessageKeyboard keyboard;
		EsMessageWindowResized windowResized;
		EsMessageAnimate animate;
		EsMessageLayout layout;
		EsMessageMeasure measure;
		EsMessageHitTest hitTest;
		EsMessageZOrder zOrder;
		EsMessageBeforeZOrder beforeZOrder;
		EsMessageItemToString itemToString;
		EsMessageFocus focus;
		EsMessageScrollWheel scrollWheel;
		EsMessageWindowActivated windowActivated;
		EsMessageScroll scroll;
		EsMessageEnsureVisible ensureVisible;
		EsStyleID childStyleVariant;
		EsRectangle *accessKeyHintBounds;
		EsPainter *painter;
		EsCursorStyle cursorStyle;
		EsElement *child;

		// List view messages:
		EsMessageIterateIndex iterateIndex;
		EsMessageItemRange itemRange;
		EsMessageMeasureItem measureItem;
		EsMessageCreateItem createItem;
		EsMessageGetContent getContent;
		EsMessageGetIndent getIndent;
		EsMessageSelectRange selectRange;
		EsMessageSelectItem selectItem;
		EsMessageChooseItem chooseItem;
		EsMessageSearchItem searchItem;
		EsMessageColumnMenu columnMenu;
		EsMessageGetColumnSort getColumnSort;
		EsMessageGetItemData getItemData;

		// Specific element messages:
		EsMessageSliderMoved sliderMoved;
		EsMessageColorChanged colorChanged;
		EsMessageNumberDragDelta numberDragDelta;
		EsMessageNumberUpdated numberUpdated;
		EsMessageGetBreadcrumb getBreadcrumb;
		EsMessageEndEdit endEdit;
		uintptr_t activateBreadcrumb;
		EsCheckState checkState;

		// Instance messages:
		EsMessageInstanceOpen instanceOpen;
		EsMessageInstanceSave instanceSave;

		// Internal messages:
		void *_argument;
		EsMessageProcessCrash crash;
		EsMessageEyedrop eyedrop;
		EsMessageCreateInstance createInstance;
		EsMessageTabOperation tabOperation;
		EsMessageDevice device;
		EsObjectID embeddedWindowDestroyedID;
	};
} @opaque();

private struct _EsMessageWithObject {
	void *object;
	EsMessage message;
};

struct EsThreadEventLogEntry {
	char file[31];
	uint8_t fileBytes;
	char expression[31];
	uint8_t expressionBytes;
	uint8_t event;
	uint16_t line;
	EsObjectID objectID, threadID;
};

struct EsMemoryStatistics {
	size_t fixedHeapAllocationCount;
	size_t fixedHeapTotalSize;
	size_t coreHeapAllocationCount;
	size_t coreHeapTotalSize;
	size_t cachedNodes;
	size_t cachedDirectoryEntries;
	size_t totalSurfaceBytes;
	size_t commitPageable;
	size_t commitFixed;
	size_t commitLimit;
	size_t commitFixedLimit;
	size_t commitRemaining;
	size_t maximumObjectCachePages;
	size_t approximateObjectCacheSize;
	size_t countZeroedPages;
	size_t countFreePages; 
	size_t countStandbyPages;
	size_t countActivePages;
};

struct EsFontInformation {
	char name[96];
	size_t nameBytes;
	char category[32];
	size_t categoryBytes;
	EsFontFamily id;
	uint16_t availableWeightsNormal;
	uint16_t availableWeightsItalic;
};

struct EsBlockDeviceInformation {
	size_t sectorSize;
	EsFileOffset sectorCount;
	bool readOnly;
	uint8_t nestLevel;
	uint8_t driveType;
	uint8_t modelBytes;
	char model[64];
};

struct EsOpenDocumentInformation {
	bool isOpen, isModified;
	uint8_t applicationNameBytes;
	char applicationName[128];
};

struct EsDateComponents {
	uint16_t year;
	uint8_t  month;       // 1-12.
	uint8_t  day;         // Starting at 1.
	uint8_t  hour;        // 0-23.
	uint8_t  minute;      // 0-59. 
	uint8_t  second;      // 0-59.
	uint8_t  _unused;
	uint16_t millisecond; // 0-999.
};

struct EsListViewEnumString {
	STRING string;
};

private struct EsMountPoint {
	char prefix[16];
	size_t prefixBytes;
	uintptr_t base;
	bool addedByApplication;
};

struct EsPanelBandDecorator {
	uintptr_t index, repeatEvery;
	uint8_t axis; // 0 for columns, 1 for rows.
	EsThemeAppearance appearance;
};

struct EsCornerRadii {
	uint32_t tl, tr, bl, br;
};

struct EsListViewEnumeratedVisibleItem {
	EsElement *element;
	EsListViewIndex group, index;
};

// Function pointer types.

function_pointer void EsThreadEntryCallback(EsGeneric argument);
function_pointer void EsSwapCallback(const void *left, const void *right, EsGeneric context);
function_pointer int EsCRTComparisonCallback(const void *left, const void *right);
function_pointer void EsTimerCallback(EsGeneric argument);
function_pointer void EsMenuCallback(EsMenu *menu, EsGeneric context); 
function_pointer void EsUndoCallback(const void *item, EsUndoManager *manager, EsMessage *message);
function_pointer void EsFontEnumerationCallback(const EsFontInformation *information, EsGeneric context);
function_pointer void EsUserTaskCallback(EsUserTask *task, EsGeneric data);
function_pointer bool EsFileCopyCallback(EsFileOffset bytesCopied, EsFileOffset totalBytes, EsGeneric data); // Return false to cancel.
function_pointer void EsWorkCallback(EsGeneric context);

// System.

function void EsApplicationStart(ES_INSTANCE_TYPE *instance, const EsApplicationStartupRequest *request) @in(request); // The instance is optional, used only for ES_APPLICATION_STARTUP_IN_SAME_CONTAINER.
function void EsApplicationRunTemporary(STRING path);
function EsHandle EsTakeSystemSnapshot(int type, size_t *bufferSize) @out(bufferSize); 
function EsInstance *_EsInstanceCreate(size_t bytes, EsMessage *message, STRING name = BLANK_STRING); 
function EsError EsHandleClose(EsHandle handle); 
function void EsSystemShowShutdownDialog();
function void EsSystemShutdown(uint32_t action);

function void EsPOSIXInitialise(int *argc, char ***argv) @native(); 
function long EsPOSIXSystemCall(long n, long a1, long a2, long a3, long a4, long a5, long a6) @native(); 
function char *EsPOSIXConvertPath(const char *path, size_t *outNameLength, bool addPOSIXMountPointPrefix) @native(); // Converts a POSIX path to a native path. Free with EsHeapFree.

private function void EsBatch(EsBatchCall *calls, size_t count); 
private function uintptr_t _EsSyscall(uintptr_t a, uintptr_t b, uintptr_t c, uintptr_t d, uintptr_t e, uintptr_t f); 
function uintptr_t _EsDebugCommand(uintptr_t a, uintptr_t b, uintptr_t c, uintptr_t d);

// Configuration and settings.

function uintptr_t EsSystemGetOptimalWorkQueueThreadCount(); 

function int64_t EsSystemConfigurationReadInteger(STRING section, STRING key, int64_t defaultValue = 0);
function char *EsSystemConfigurationReadString(STRING section, STRING key, size_t *valueBytes = ES_NULL) @out(valueBytes) @heap_buffer_out(return, valueBytes*); // Free with EsHeapFree.
function void EsSystemConfigurationReadFileTypes(EsBuffer *buffer); // Read the "file_type" sections of the system configuration INI to the buffer.

// INI files.

function bool EsINIParse(EsINIState *s);
function bool EsINIPeek(EsINIState *s);
function size_t EsINIFormat(EsINIState *s, char *buffer, size_t bytes) @native();
function void EsINIZeroTerminate(EsINIState *s);

// File systems.

function const void *EsBundleFind(const EsBundle *bundle, STRING name, size_t *byteCount = ES_NULL) @out(byteCount) @fixed_buffer_out(return, byteCount*); // Pass null as the bundle to use the current application's bundle.

function EsDirectoryChild *EsDirectoryEnumerateChildren(STRING path, size_t *count, EsError *error = ES_NULL) @out(count) @out(error) @heap_array_out(return, count*);

function void *EsFileReadAll(STRING filePath, size_t *fileSize, EsError *error = ES_NULL) @out(fileSize) @out(error) @heap_buffer_out(return, fileSize*); // Free with EsHeapFree.
function void *EsFileReadAllFromHandle(EsHandle handle, size_t *fileSize, EsError *error = ES_NULL) @out(fileSize) @out(error) @heap_buffer_out(return, fileSize*); // Free with EsHeapFree.
function EsError EsFileWriteAll(STRING filePath, const void *data, size_t fileSize) @buffer_in(data, fileSize);
function EsError EsFileWriteAllFromHandle(EsHandle handle, const void *data, size_t fileSize) @buffer_in(data, fileSize);
function EsError EsFileWriteAllGather(STRING filePath, const void **data, const size_t *sizes, size_t gatherCount) @array_in(data, gatherCount) @array_in(sizes, gatherCount) @todo(); 
function EsError EsFileWriteAllGatherFromHandle(EsHandle handle, const void **data, const size_t *sizes, size_t gatherCount) @array_in(data, gatherCount) @array_in(sizes, gatherCount) @todo(); 
function void *EsFileMap(STRING filePath, size_t *fileSize, uint32_t flags) @native();
function EsError EsFileCopy(STRING source, STRING destination, void **copyBuffer = ES_NULL, EsFileCopyCallback callback = ES_NULL, EsGeneric data = ES_NULL) @todo(); // If you are copying lots of files, you can reuse the temporary copy buffer by storing the output copyBuffer; call EsHeapFree on it after the last copy.

function EsError EsFileControl(EsHandle file, EsFileControlFlags flags); 
function EsFileInformation EsFileOpen(STRING path, EsFileOpenFlags flags);
function EsFileOffset EsFileGetSize(EsHandle handle);
function size_t EsFileReadSync(EsHandle file, EsFileOffset offset, size_t size, void *buffer) @buffer_out(buffer, size);
function EsError EsFileResize(EsHandle file, EsFileOffset newSize);
function size_t EsFileWriteSync(EsHandle file, EsFileOffset offset, size_t size, const void *buffer) @buffer_in(buffer, size);
function EsError EsFileDelete(EsHandle file);

function EsError EsPathDelete(STRING path);
function size_t EsPathFindUniqueName(char *buffer, size_t originalBytes, size_t bufferBytes) @todo();
function EsError EsPathMove(STRING oldPath, STRING newPath, EsPathMoveFlags flags = ES_FLAGS_DEFAULT);
function bool EsPathExists(STRING filePath, EsNodeType *type = ES_NULL) @out(type); // Returns true if the file/directory exists.
function EsError EsPathCreate(STRING filePath, EsNodeType type, bool createLeadingDirectories);
function bool EsPathQueryInformation(STRING filePath, EsDirectoryChild *information) @out(information);

function void *EsFileStoreReadAll(EsFileStore *file, size_t *fileSize) @heap_buffer_out(return, fileSize*) @out(fileSize); // Free with EsHeapFree.
function bool EsFileStoreWriteAll(EsFileStore *file, const void *data, size_t dataBytes) @buffer_in(data, dataBytes);
function bool EsFileStoreAppend(EsFileStore *file, const void *data, size_t dataBytes) @buffer_in(data, dataBytes);
function EsFileOffsetDifference EsFileStoreGetSize(EsFileStore *file); // Returns -1 on error.
function void *EsFileStoreMap(EsFileStore *file, size_t *fileSize, uint32_t flags) @native();

// These calls require permission_all_files.
function bool EsMountPointGetVolumeInformation(STRING prefix, EsVolumeInformation *information) @out(information); // Returns false if the mount point does not exist.
function EsError EsMountPointAdd(STRING prefix, EsHandle base); // The system maintains a duplicate of the base handle.
function bool EsMountPointRemove(STRING prefix); // Returns false if the mount point does not exist. You can only remove mount points you added with EsMountPointAdd.
function void EsOpenDocumentQueryInformation(STRING filePath, EsOpenDocumentInformation *information) @out(information);
function void _EsPathAnnouncePathMoved(STRING oldPath, STRING newPath); // Set oldPathBytes = 0 to make the file manager refresh the path.
function void _EsOpenDocumentEnumerate(EsBuffer *outputBuffer);

function EsMessageDevice *EsDeviceEnumerate(size_t *count) @out(count) @heap_array_out(return, count*); // This must be done with the message mutex acquired. As soon as EsMessageReceived is next called, or the message mutex is released, then the handles in this array are invalid.
function EsError EsDeviceControl(EsHandle handle, EsDeviceControlType type, void *dp, void *dq) @native();

// Processes and threads.

function EsError EsProcessCreate(const EsProcessCreationArguments *arguments, EsProcessInformation *information) @in(arguments) @array_in(arguments**handles, arguments**handleCount) @array_in(arguments**handleModes, arguments**handleCount) @out(information); 
function int EsProcessGetExitStatus(EsHandle process); 
function EsObjectID EsProcessGetID(EsHandle process);
function void EsProcessGetState(EsHandle process, EsProcessState *state) @out(state); 
function void EsProcessGetCreateData(EsProcessCreateData *data) @out(data); // For the current process.
function EsHandle EsProcessOpen(EsObjectID pid); 
function void EsProcessPause(EsHandle process, bool resume); 
function void EsProcessTerminate(EsHandle process, int status); 
function void EsProcessTerminateCurrent(); 

function EsError EsThreadCreate(EsThreadEntryCallback entryFunction, EsThreadInformation *information, EsGeneric argument) @out(information) @todo(); 
function EsObjectID EsThreadGetID(EsHandle thread);
function void EsThreadTerminate(EsHandle thread); 

function EsError EsWorkQueue(EsWorkCallback callback, EsGeneric context) @todo();
function bool EsWorkIsExiting();

// Memory.

function const void *EsBufferRead(EsBuffer *buffer, size_t readBytes) @native();
function bool EsBufferReadInto(EsBuffer *buffer, void *destination, size_t readBytes) @buffer_out(destination, readBytes);
function const void *EsBufferReadMany(EsBuffer *buffer, size_t a, size_t b) @native();
function int32_t EsBufferReadInt32Endian(EsBuffer *buffer, int32_t errorValue);
function void *EsBufferWrite(EsBuffer *buffer, const void *source, size_t writeBytes) @buffer_in(source, writeBytes) @todo();
function bool EsBufferWriteInt8(EsBuffer *buffer, int8_t value);
function bool EsBufferWriteInt32Endian(EsBuffer *buffer, int32_t value); // Changes byte order if big endian.
function void EsBufferFormat(EsBuffer *buffer, EsCString format, ...) @native(); // Appends.
function void EsBufferFormatV(EsBuffer *buffer, EsCString format, va_list arguments) @native(); // Appends.
function void EsBufferFlushToFileStore(EsBuffer *buffer);

function EsHandle EsConstantBufferCreate(const void *data, size_t dataBytes, EsHandle targetProcess) @buffer_in(data, dataBytes); 
function void EsConstantBufferRead(EsHandle constantBuffer, void *output) @todo();
function EsHandle EsConstantBufferShare(EsHandle constantBuffer, EsHandle targetProcess);
function size_t EsConstantBufferGetSize(EsHandle constantBuffer);

function_not_in_kernel void *EsHeapAllocate(size_t size, bool zeroMemory, EsHeap *heap = ES_NULL) @native();
function_not_in_kernel void EsHeapFree(void *address, size_t expectedSize = 0, EsHeap *heap = ES_NULL) @native();
function_not_in_kernel void *EsHeapReallocate(void *oldAddress, size_t newAllocationSize, bool zeroNewSpace, EsHeap *heap = ES_NULL) @native();

function void EsHeapValidate() @native(); 

function EsHandle EsMemoryCreateShareableRegion(size_t bytes);
function bool EsMemoryCommit(void *pointer, size_t bytes) @native();
function int EsMemoryCompare(const void *a, const void *b, size_t bytes) @native(); 
function void EsMemoryCopy(void *destination, const void *source, size_t bytes) @native(); 
function void EsMemoryCopyReverse(void *_destination, const void *_source, size_t bytes) @native(); 
function bool EsMemoryDecommit(void *pointer, size_t bytes) @native(); // May fail in low-memory conditions when the commit ranges on the region are fragmented. (Cannot fail if you decommit the entire region.)
function void EsMemoryFaultRange(const void *pointer, size_t bytes, uint32_t flags = ES_FLAGS_DEFAULT) @native(); // Simulate a page fault in each page in the range.
function void EsMemoryFill(void *from, void *to, uint8_t byte) @native(); 
function void EsMemoryMove(void *_start, void *_end, intptr_t amount, bool zeroEmptySpace) @native(); 
function void *EsMemoryReserve(size_t size, EsMemoryProtection protection = ES_MEMORY_PROTECTION_READ_WRITE, EsMemoryReserveFlags flags = ES_MEMORY_RESERVE_COMMIT_ALL) @native(); 
function EsHandle EsMemoryShare(EsHandle sharedMemoryRegion, EsHandle targetProcess, bool readOnly); 
function uint8_t EsMemorySumBytes(uint8_t *data, size_t bytes) @native(); 
function void EsMemoryUnreserve(void *pointer, size_t size = 0) @native(); // Must cover the entire reserved region. Leave size 0 if you don't know the size.
function void EsMemoryZero(void *destination, size_t bytes) @native(); 

function void *EsMemoryMapObject(EsHandle object, uintptr_t offset, size_t size, EsMemoryMapFlags flags) @native(); 

// Standard functions.

function void EsAssertionFailure(EsCString cFile, int line); 

function EsCalculationValue EsCalculateFromUserExpression(EsCString cExpression); // For user input only; do not rely on consistent behaviour across versions; use with message mutex.

function void EsPanic(EsCString format, ...) @native(); 
function void EsPrint(EsCString format, ...) @native();
function void EsPrintDirect(STRING string); 
function void EsPrintHelloWorld(); 

function uint8_t EsRandomU8(); 
function uint64_t EsRandomU64();
function void EsRandomAddEntropy(uint64_t x); 
function void EsRandomSeed(uint64_t x); 

function EsRectangle EsRectangleAdd(EsRectangle a, EsRectangle b);
function EsRectangle EsRectangleAddBorder(EsRectangle rectangle, EsRectangle border);
function EsRectangle EsRectangleBounding(EsRectangle a, EsRectangle b);
function EsRectangle EsRectangleCenter(EsRectangle parent, EsRectangle child);
function EsRectangle EsRectangleCut(EsRectangle a, int32_t amount, char side);
function EsRectangle EsRectangleFit(EsRectangle parent, EsRectangle child, bool allowScalingUp); // Preserves aspect ratio.
function EsRectangle EsRectangleIntersection(EsRectangle a, EsRectangle b);
function EsRectangle EsRectangleLinearInterpolate(EsRectangle a, EsRectangle b, float progress);
function EsRectangle EsRectangleSplit(EsRectangle *a, int32_t amount, char side, int32_t gap = 0) @in_out(a); // Same as EsRectangleCut, but the source rectangle is modified.
function EsRectangle EsRectangleSubtract(EsRectangle a, EsRectangle b);
function EsRectangle EsRectangleTranslate(EsRectangle a, EsRectangle b);
function bool EsRectangleEquals(EsRectangle a, EsRectangle b);
function bool EsRectangleContains(EsRectangle a, int32_t x, int32_t y);
function bool EsRectangleContainsAll(EsRectangle parent, EsRectangle child); // Returns true iff the child rectangle is entirely contained within parent.

// Graphics.

function uint32_t EsColorBlend(uint32_t under, uint32_t over, bool fullAlpha);
function bool EsColorIsLight(uint32_t color); // Returns true if you should black to draw atop the color.
function uint32_t EsColorConvertToRGB(float h, float s, float v); // 0 <= hue < 6; 0 <= saturation <= 1; 0 <= value <= 1.
function bool EsColorConvertToHSV(uint32_t color, float *h, float *s, float *v) @out(h) @out(s) @out(v);
function uint32_t EsColorParse(STRING string);
function uint32_t EsColorInterpolate(uint32_t from, uint32_t to, float progress);

function void EsDrawBitmap(EsPainter *painter, EsRectangle region, const uint32_t *bits, uintptr_t stride, uint16_t mode) @matrix_in(bits, region, stride); // OR mode with alpha.
function void EsDrawBitmapScaled(EsPainter *painter, EsRectangle destinationRegion, EsRectangle sourceRegion, const uint32_t *bits, uintptr_t stride, uint16_t alpha) @matrix_in(bits, sourceRegion, stride); // Set alpha to 0xFFFF if source is opaque.
function void EsDrawBlock(EsPainter *painter, EsRectangle bounds, EsDeviceColor mainColor);
function void EsDrawClear(EsPainter *painter, EsRectangle bounds);
function void EsDrawContent(EsPainter *painter, EsElement *element, EsRectangle rectangle, STRING text, uint32_t iconID = 0, EsDrawContentFlags flags = ES_FLAGS_DEFAULT, const EsTextSelection *selectionProperties = ES_NULL) @in(selectionProperties);
function void EsDrawInvert(EsPainter *painter, EsRectangle bounds);
function void EsDrawLine(EsPainter *painter, const float *vertices, size_t vertexCount, EsDeviceColor color, float width, EsDrawLineFlags flags) @array_in(vertices, vertexCount); // Vertices are pairs of x,y coordinates.
function void EsDrawRectangle(EsPainter *painter, EsRectangle bounds, EsDeviceColor mainColor, EsDeviceColor borderColor, EsRectangle borderSize);
function void EsDrawRoundedRectangle(EsPainter *painter, EsRectangle bounds, EsDeviceColor mainColor, EsDeviceColor borderColor, EsRectangle borderSize, EsCornerRadii cornerRadii);
function bool EsDrawStandardIcon(EsPainter *painter, uint32_t id, int size, EsRectangle region, EsDeviceColor color);
function void EsDrawPaintTarget(EsPainter *painter, EsPaintTarget *source, EsRectangle destinationRegion, EsRectangle sourceRegion, uint8_t alpha); 
function void EsDrawText(EsPainter *painter, EsTextPlan *plan, EsRectangle bounds, const EsRectangle *clip = ES_NULL, const EsTextSelection *selectionProperties = ES_NULL) @in(selectionProperties) @in(clip); 
function void EsDrawTextSimple(EsPainter *painter, EsElement *element, EsRectangle bounds, STRING stringBytes, EsTextStyle style, uint32_t flags = ES_FLAGS_DEFAULT);
function void EsDrawTextThemed(EsPainter *painter, EsElement *element, EsRectangle bounds, STRING stringBytes, EsStyleID style, uint32_t flags = ES_FLAGS_DEFAULT); // The style must be one of the ES_STYLE_TEXT_... styles.
function void EsDrawTextLayers(EsPainter *painter, EsTextPlan *plan, EsRectangle bounds, const EsTextSelection *selectionProperties = ES_NULL) @in(selectionProperties); 
function void EsDrawVectorFile(EsPainter *painter, EsRectangle bounds, const void *data, size_t dataBytes) @buffer_in(data, dataBytes);

function uint32_t EsIconIDFromString(STRING string = BLANK_STRING);
function uint32_t EsIconIDFromDriveType(uint8_t driveType);

function uint8_t *EsImageLoad(const void *file, size_t fileSize, uint32_t *width, uint32_t *height, int imageChannels) @out(width) @out(height) @buffer_in(file, fileSize) @heap_matrix_out(return, width*, height*);

function EsRectangle EsPainterBoundsClient(EsPainter *painter); 
function EsRectangle EsPainterBoundsInset(EsPainter *painter); 

function void EsPaintTargetClear(EsPaintTarget *target);
function void EsPaintTargetEndDirectAccess(EsPaintTarget *target);
function void EsPaintTargetStartDirectAccess(EsPaintTarget *target, uint32_t **bits, size_t *width, size_t *height, size_t *stride) @out(bits) @out(width) @out(height) @out(stride) @matrix_shared(bits*, width*, height*);
function EsPaintTarget *EsPaintTargetCreate(size_t width, size_t height, bool hasAlphaChannel);
function EsPaintTarget *EsPaintTargetCreateFromBitmap(uint32_t *bits, size_t width, size_t height, bool hasAlphaChannel) @matrix_shared(bits, width, height); // Do not access the bits again until calling EsPaintTargetDestroy!
function void EsPaintTargetGetSize(EsPaintTarget *target, size_t *width, size_t *height) @out(width) @out(height);
function void EsPaintTargetDestroy(EsPaintTarget *target);

function EsTextPlan *EsTextPlanCreate(EsElement *element, EsTextPlanProperties *properties, EsRectangle bounds, const char *string, const EsTextRun *textRuns, size_t textRunCount) @todo(); // textRuns should point to an array of (textRunCount + 1) EsTextRuns; the last one should have its offset set to the total number of bytes in the string. The passed string must remain valid until the plan is destroyed. The element is used for UI scaling calculations.
function int EsTextPlanGetWidth(EsTextPlan *plan); // TODO Public property?
function int EsTextPlanGetHeight(EsTextPlan *plan); // TODO Public property?
function size_t EsTextPlanGetLineCount(EsTextPlan *plan); // TODO Public property?
function void EsTextPlanDestroy(EsTextPlan *plan);
function void EsTextPlanReplaceStyleRenderProperties(EsTextPlan *plan, const EsTextStyle *style) @in(style); // Only render properties - like color or underline, but not font weight - will be replaced.

function void EsRichTextParse(const char *inString, ptrdiff_t inStringBytes, char **outString, EsTextRun **outTextRuns, size_t *outTextRunCount, EsTextStyle *baseStyle) @todo();

function EsFontInformation *EsFontDatabaseEnumerate(size_t *count) @out(count) @heap_array_out(return, count*);
function bool EsFontDatabaseLookupByName(STRING name, EsFontInformation *information) @out(information); // Returns false if the font does not exist in the database.
function bool EsFontDatabaseLookupByID(EsFontFamily id, EsFontInformation *information) @out(information); // Returns false if the font does not exist in the database.
function EsFontFamily EsFontDatabaseInsertFile(const EsFontInformation *information, EsFileStore *store) @in(information); // Don't set the `id` field in EsFontInformation. The assigned ID will be returned. If nameBytes is 0, then the system will not try to match it with an existing font family. Set the corresponding bit in availableWeightsNormal/availableWeightsItalic for the file being added. The request is ignored if the specific variant is already in the database.

function EsStyleID EsStyleIntern(const EsStyle *style) @in(style); // Once a style has been interned, it cannot be removed. Duplicate styles will be given the same ID.
// TODO Add an alternative API which allows for adding and removing styles dynamically.

// Networking.

function EsError EsAddressResolve(STRING domain, uint32_t flags, EsAddress *address);
function void EsConnectionClose(EsConnection *connection);
function void EsConnectionNotify(EsConnection *connection);
function EsError EsConnectionOpen(EsConnection *connection, EsConnectionOpenFlags flags);
function void EsConnectionPoll(EsConnection *connection);
function EsError EsConnectionRead(EsConnection *connection, void *buffer, size_t bufferBytes, size_t *bytesRead) @buffer_out(buffer, bufferBytes) @out(bytesRead); // Returns the number of bytes copied into the buffer.
function EsError EsConnectionWriteSync(EsConnection *connection, const void *data, size_t dataBytes) @buffer_in(data, dataBytes); // Waits until all the data has been written into the send buffer. This does *not* flush the send buffer.

// Input.

function size_t EsGameControllerStatePoll(EsGameControllerState *buffer) @todo(); // Returns number of connected controllers. Buffer must have space for ES_GAME_CONTROLLER_MAX_COUNT.

function uint8_t EsKeyboardGetModifiers(); // Synchronous with respect to message processing.

function EsPoint EsMouseGetPosition(EsElement *relativeElement = ES_NULL); 
function EsError EsMouseSetPosition(EsWindow *relativeWindow, int x, int y); // The request will be rejected if the user is not clicking on your window.
function bool EsMouseIsLeftHeld();
function bool EsMouseIsRightHeld();
function bool EsMouseIsMiddleHeld();

// Pipes.

function void EsPipeCreate(EsHandle *readEnd, EsHandle *writeEnd) @out(readEnd) @out(writeEnd);
function size_t EsPipeRead(EsHandle pipe, void *buffer, size_t bytes, bool allowShortReads) @buffer_out(buffer, bytes); // If buffer is null, then the data is discarded. If allowShortReads is false, then the call will block until the buffer is full or there are no writers; if allowShortReads is true, then the call will block until the buffer is non-empty or there are no writers. Note that the modes are equivalent iff bytes is 0 or 1.
function size_t EsPipeWrite(EsHandle pipe, const void *buffer, size_t bytes) @buffer_in(buffer, bytes);

// Synchronisation and timing.

function EsHandle EsEventCreate(bool autoReset); 
function void EsEventReset(EsHandle event); 
function void EsEventSet(EsHandle event); 

function void EsMutexAcquire(EsMutex *mutex) @native(); 
function void EsMutexDestroy(EsMutex *mutex) @native(); 
function void EsMutexRelease(EsMutex *mutex) @native(); 

function void EsSchedulerYield(); 

function void EsSpinlockAcquire(EsSpinlock *spinlock) @native(); 
function void EsSpinlockRelease(EsSpinlock *spinlock) @native(); 

function EsTimer EsTimerSet(uint64_t afterMs, EsTimerCallback callback, EsGeneric argument) @todo(); 
function void EsTimerCancel(EsTimer id);

function void EsSleep(uint64_t milliseconds); 
function uintptr_t EsWait(const EsHandle *objects, size_t objectCount, uintptr_t timeoutMs) @array_in(objects, objectCount);  

function double EsTimeStampMs(); // Current value of the performance timer, in ms.

function void EsDateNowUTC(EsDateComponents *date) @out(date); // Don't rely on the accuracy of the millisecond field.
private function uint64_t DateToLinear(const EsDateComponents *date);

// Strings.

function size_t EsCStringLength(EsCString string); 
function char *EsStringAllocateAndFormat(size_t *bytes, EsCString format, ...) @native(); // Zero-terminated.
function char *EsStringAllocateAndFormatV(size_t *bytes, EsCString format, va_list arguments) @native(); 
function int EsStringCompare(STRING s1, STRING s2); 
function int EsStringCompareRaw(STRING s1, STRING s2); 
function ptrdiff_t EsStringFormat(char *buffer, size_t bufferLength, EsCString format, ...) @native(); // Not zero-terminated.
function const char *EsStringFormatTemporary(EsCString format, ...) @native();  // Not thread safe. The result is valid until the next call. Zero-terminated.
function ptrdiff_t EsStringFormatV(char *buffer, size_t bufferLength, EsCString format, va_list arguments) @native(); 
function bool EsStringFormatAppend(char *buffer, size_t bufferLength, size_t *bufferPosition, EsCString format, ...) @native(); // Return false if buffer filled.
function bool EsStringFormatAppendV(char *buffer, size_t bufferLength, size_t *bufferPosition, EsCString format, va_list arguments) @native(); 
function bool EsUTF8IsValid(STRING input); // Does not check for surrogate characters or overlong sequences of non-ASCII characters.

function double EsDoubleParse(STRING string, char **endptr) @native(); 
function int64_t EsIntegerParse(STRING text); // Parses in hexadecimal if the first two characters are '0x'.

// CRT functions.

function int EsCRTabs(int n); 
function float EsCRTacosf(float x); 
function float EsCRTasinf(float x); 
function double EsCRTatan2(double y, double x); 
function float EsCRTatan2f(float y, float x); 
function float EsCRTatanf(float x); 
function double EsCRTatod(EsCString string); 
function int EsCRTatoi(EsCString string); 
function float EsCRTatof(EsCString string); 
function void *EsCRTbsearch(const void *key, const void *base, size_t num, size_t size, EsCRTComparisonCallback compar) @native();
function void *EsCRTcalloc(size_t num, size_t size) @native(); 
function double EsCRTcbrt(double x);
function float EsCRTcbrtf(float x);
function double EsCRTceil(double x); 
function float EsCRTceilf(float x); 
function double EsCRTcos(double x); 
function float EsCRTcosf(float x); 
function double EsCRTexp(double x);
function float EsCRTexpf(float x);
function double EsCRTexp2(double x);
function float EsCRTexp2f(float x);
function double EsCRTfabs(double x); 
function float EsCRTfabsf(float x); 
function double EsCRTfloor(double x); 
function float EsCRTfloorf(float x); 
function double EsCRTfmod(double x, double y); 
function float EsCRTfmodf(float x, float y); 
function void EsCRTfree(void *ptr) @native(); 
function char *EsCRTgetenv(EsCString name) @native(); 
function int EsCRTisalpha(int c); 
function int EsCRTisdigit(int c); 
function bool EsCRTisnanf(float f); 
function int EsCRTisspace(int c); 
function int EsCRTisupper(int c);
function int EsCRTisxdigit(int c);
function double EsCRTlog2(double x); 
function float EsCRTlog2f(float x); 
function void *EsCRTmalloc(size_t size) @native(); 
function void *EsCRTmemchr(const void *_s, int _c, size_t n) @native(); 
function int EsCRTmemcmp(const void *s1, const void *s2, size_t n) @native(); 
function void *EsCRTmemcpy(void *dest, const void *src, size_t n) @native(); 
function void *EsCRTmemmove(void *dest, const void *src, size_t n) @native(); 
function void *EsCRTmemset(void *s, int c, size_t n) @native(); 
function double EsCRTpow(double x, double y);
function float EsCRTpowf(float x, float y);
function void EsCRTqsort(void *_base, size_t nmemb, size_t size, EsCRTComparisonCallback compar) @native(); 
function int EsCRTrand();
function void *EsCRTrealloc(void *ptr, size_t size) @native(); 
function double EsCRTsin(double x); 
function float EsCRTsinf(float x); 
function int EsCRTsnprintf(char *buffer, size_t bufferSize, EsCString format, ...) @native(); 
function int EsCRTsprintf(char *buffer, EsCString format, ...) @native(); 
function double EsCRTsqrt(double x); 
function float EsCRTsqrtf(float x); 
function char *EsCRTstrcat(char *dest, EsCString src) @native(); 
function char *EsCRTstrchr(EsCString s, int c) @native(); 
function int EsCRTstrcmp(EsCString s1, EsCString s2); 
function char *EsCRTstrcpy(char *dest, EsCString src) @native(); 
function char *EsCRTstrdup(EsCString string) @native(); 
function char *EsCRTstrerror(int errnum) @native(); 
function size_t EsCRTstrlen(EsCString s); 
function int EsCRTstrncmp(EsCString s1, EsCString s2, size_t n); 
function char *EsCRTstrncpy(char *dest, EsCString src, size_t n) @native(); 
function size_t EsCRTstrnlen(EsCString s, size_t maxlen); 
function char *EsCRTstrstr(EsCString haystack, EsCString needle) @native(); 
function double EsCRTstrtod(EsCString nptr, char **endptr) @native(); 
function float EsCRTstrtof(EsCString nptr, char **endptr) @native(); 
function long EsCRTstrtol(EsCString nptr, char **endptr, int base) @native(); 
function uint64_t EsCRTstrtoul(EsCString nptr, char **endptr, int base) @native(); 
function int EsCRTtolower(int c); 
function int EsCRTvsnprintf(char *buffer, size_t bufferSize, EsCString format, va_list arguments) @native(); 

// Clipboard and undo.

function EsError EsClipboardAddText(EsClipboard clipboard, STRING text = BLANK_STRING);
function bool EsClipboardHasFormat(EsClipboard clipboard, EsClipboardFormat format);
function bool EsClipboardHasData(EsClipboard clipboard);
function char *EsClipboardReadText(EsClipboard clipboard, size_t *bytes, EsClipboardDataFlags *flags = ES_NULL) @out(flags) @heap_buffer_out(return, bytes*) @out(bytes); // Free with EsHeapFree.
function EsFileStore *EsClipboardOpen(EsClipboard clipboard); // Open the clipboard for writing.
function EsError EsClipboardCloseAndAdd(EsClipboard clipboard, EsClipboardFormat format, EsFileStore *fileStore, EsClipboardDataFlags flags = ES_FLAGS_DEFAULT);

function void EsUndoClear(EsUndoManager *manager);
function void EsUndoContinueGroup(EsUndoManager *manager);
function void EsUndoEndGroup(EsUndoManager *manager);
function void EsUndoInvokeGroup(EsUndoManager *manager, bool redo);
function bool EsUndoPeek(EsUndoManager *manager, EsUndoCallback *callback, const void **item) @todo();
function void EsUndoPop(EsUndoManager *manager);
function void EsUndoPush(EsUndoManager *manager, EsUndoCallback callback, const void *item, size_t itemBytes, bool setAsActiveUndoManager = true) @buffer_in(item, itemBytes) @todo();
function bool EsUndoInUndo(EsUndoManager *manager);
function bool EsUndoIsEmpty(EsUndoManager *manager, bool redo);
function ES_INSTANCE_TYPE *EsUndoGetInstance(EsUndoManager *manager);

// Instances and commands.

function void EsCommandAddButton(EsCommand *command, EsButton *button);
function EsCommand *EsCommandByID(ES_INSTANCE_TYPE *instance, uint32_t stableID);
function EsCommand *EsCommandRegister(EsCommand *command, ES_INSTANCE_TYPE *instance, STRING title, EsCommandCallback callback, uint32_t stableID, EsCString cDefaultKeyboardShortcut = ES_NULL, bool enabled = false) @todo(); // IDs >= 0xF0000000 reserved by the system.
function void EsCommandSetCallback(EsCommand *command, EsCommandCallback callback) @todo();
function void EsCommandSetDisabled(EsCommand *command, bool disabled);
function void EsCommandSetCheck(EsCommand *command, EsCheckState check, bool sendUpdatedMessage);

function void EsInstanceOpenReference(ES_INSTANCE_TYPE *_instance);
function void EsInstanceCloseReference(ES_INSTANCE_TYPE *_instance); // Sends ES_MSG_INSTANCE_DESTROY when all references closed.
function void EsInstanceClose(ES_INSTANCE_TYPE *instance); // Sends ES_MSG_INSTANCE_CLOSE, and closes the window's reference to the instance.
function void EsInstanceSetActiveUndoManager(ES_INSTANCE_TYPE *instance, EsUndoManager *manager);
function void EsInstanceSetClassEditor(ES_INSTANCE_TYPE *instance, const EsInstanceClassEditorSettings *settings) @in(settings);
function void EsInstanceSetClassViewer(ES_INSTANCE_TYPE *instance, const EsInstanceClassViewerSettings *settings) @in(settings);
function EsApplicationStartupRequest EsInstanceGetStartupRequest(ES_INSTANCE_TYPE *instance);
function void EsInstanceOpenComplete(ES_INSTANCE_TYPE *instance, EsFileStore *file, bool success, STRING errorText = BLANK_STRING);
function void EsInstanceSaveComplete(ES_INSTANCE_TYPE *instance, EsFileStore *file, bool success);
function void EsInstanceSetModified(ES_INSTANCE_TYPE *instance, bool modified);

function EsError EsUserTaskStart(EsUserTaskCallback callback, EsGeneric data, STRING title, uint32_t iconID) @todo();
function void EsUserTaskSetProgress(EsUserTask *task, double progress, EsFileOffsetDifference bytesPerSecond); // Set bytesPerSecond to -1 if not applicable.
function bool EsUserTaskIsRunning(EsUserTask *task); // Returns false if the task was cancelled.

// Message processing.

function size_t EsMessageGetInputText(EsMessage *message, char *buffer) @todo(); // The buffer should be 64 bytes in size. 
function void EsMessageMutexAcquire(); 
function void EsMessageMutexCheck();
function void EsMessageMutexRelease(); 
function EsError EsMessagePost(EsElement *target, EsMessage *message); 
function EsError EsMessagePostRemote(EsHandle process, EsMessage *message); 
function int EsMessageSend(EsElement *object, EsMessage *message);
function EsMessage *EsMessageReceive();

// User interface elements.

function void EsElementDraw(EsElement *element, EsPainter *painter); // Actually draw an element onto a painter.
function void EsElementFocus(EsElement *element, EsElementFocusFlags flags = ES_FLAGS_DEFAULT);
function bool EsElementIsFocused(EsElement *element);
function void EsElementSetDisabled(EsElement *element, bool disabled = true);
function void EsElementSetHidden(EsElement *element, bool hidden = true);
function bool EsElementIsHidden(EsElement *element);
function void EsElementSetCallback(EsElement *element, EsElementCallback callback) @todo();
function void EsElementGetSize(EsElement *element, int *width, int *height) @out(width) @out(height);
function void EsElementRepaint(EsElement *element, const EsRectangle *region = ES_NULL) @in(region); // Mark an element to be repainted. If region is null, then the whole element is repainted.
function void EsElementRepaintForScroll(EsElement *element, EsMessage *message, EsRectangle border); // Minimal repaint for ES_MSG_SCROLL_X/Y.
function void EsElementRelayout(EsElement *element);
function void EsElementSetCellRange(EsElement *element, int xFrom, int yFrom, int xTo = -1, int yTo = -1); // Use only if the parent is a ES_PANEL_TABLE.
function EsRectangle EsElementGetInsets(EsElement *element); 
function EsRectangle EsElementGetInsetSize(EsElement *element); // Get the size of the element, minus the insets.
function EsRectangle EsElementGetInsetBounds(EsElement *element);
function EsThemeMetrics EsElementGetMetrics(EsElement *element); // Returns the *scaled* metrics; the metrics given in the EsStyle passed to element creation functions should *not* be scaled.
function float EsElementGetScaleFactor(EsElement *element);
function EsRectangle EsElementGetPreferredSize(EsElement *element);
function void EsElementMove(EsElement *element, int x, int y, int width, int height, bool applyCellLayout = true); // x, y are given relative to the top-left of the parent.
function EsElement *EsElementGetLayoutParent(EsElement *element);
function void EsElementDestroy(EsElement *element);
function void EsElementDestroyContents(EsElement *element);
function bool EsElementStartAnimating(EsElement *element); // Returns false if the element was already animating.
function void EsElementStartTransition(EsElement *element, EsTransitionType transitionType, EsElementTransitionFlags flags = ES_FLAGS_DEFAULT, float timeMultiplier = 1); // TODO More customization.
function void EsElementInsertAfter(EsElement *element); // The next element created will be inserted after this element. They must have the same parent. Or, if this is the parent of the next element created, then it will be inserted at the start of the parent.
function void EsElementUpdateContentSize(EsElement *element, EsElementUpdateContentFlags flags = ES_FLAGS_DEFAULT);
function void EsElementGetTextStyle(EsElement *element, EsTextStyle *style) @out(style);
function EsRectangle EsElementGetWindowBounds(EsElement *element, bool client = true);
function EsRectangle EsElementGetScreenBounds(EsElement *element, bool client = true);

// TODO Rename these functions?
function EsElement *EsCustomElementCreate(EsElement *parent, EsElementFlags flags = ES_FLAGS_DEFAULT, EsStyleID style = 0);
function EsScrollView *EsCustomScrollViewCreate(EsElement *parent, EsElementFlags flags = ES_FLAGS_DEFAULT, EsStyleID style = 0);

function int EsScrollViewReceivedMessage(EsScrollView *view, EsMessage *message); // You *must* call this *before* handling any messages. If this returns non-zero, immediately return that value from your message handler.
function void EsScrollViewSetup(EsScrollView *view, EsScrollViewMode xMode, EsScrollViewMode yMode, uint16_t flags);
function void EsScrollViewSetPosition(EsScrollView *view, int axis, double newPosition, bool sendMovedMessage = true);
function void EsScrollViewRefresh(EsScrollView *view);
function int64_t EsScrollViewGetPosition(EsScrollView *view, int axis);
function int64_t EsScrollViewGetLimit(EsScrollView *view, int axis);
function void EsScrollViewSetFixedViewport(EsScrollView *view, int axis, int32_t value);
function bool EsScrollViewIsBarEnabled(EsScrollView *view, int axis);
function bool EsScrollViewIsInDragScroll(EsScrollView *view);

// Windows, menus, popups, toolbars and dialogs.

function EsWindow *EsWindowCreate(ES_INSTANCE_TYPE *instance, EsWindowStyle style);
function EsRectangle EsWindowGetBounds(EsWindow *window);
function EsElement *EsWindowGetToolbar(EsWindow *window, bool createNew = false);
function void EsWindowSwitchToolbar(EsWindow *window, EsElement *toolbar, EsTransitionType transitionType);
function void EsWindowSetIcon(EsWindow *window, uint32_t iconID);
function void EsWindowSetTitle(EsWindow *window, STRING title = BLANK_STRING);
function void EsWindowAddSizeAlternative(EsWindow *window, EsElement *small, EsElement *big, int widthThreshold, int heightThreshold); // Switch between elements when the window size goes below a threshold.

function EsMenu *EsMenuCreate(EsElement *source, EsMenuFlags flags = ES_FLAGS_DEFAULT);
function EsElement *EsMenuGetSource(EsMenu *menu); // TODO Public property?
function void EsMenuAddItem(EsMenu *menu, EsMenuItemFlags flags, STRING label = BLANK_STRING, EsMenuCallback callback = ES_NULL, EsGeneric context = ES_NULL) @todo();
function void EsMenuAddCommand(EsMenu *menu, EsMenuItemFlags flags, STRING label, EsCommand *command);
function void EsMenuAddSeparator(EsMenu *menu);
function void EsMenuNextColumn(EsMenu *menu, EsElementFlags flags = ES_FLAGS_DEFAULT);
function void EsMenuShow(EsMenu *menu, int fixedWidth = 0, int fixedHeight = 0);
function void EsMenuClose(EsMenu *menu);
function void EsMenuCloseAll();
function void EsMenuAddCommandsFromToolbar(EsMenu *menu, EsElement *element);

function EsDialog *EsDialogShow(EsWindow *window, STRING title, STRING content, uint32_t iconID, EsDialogShowFlags flags = ES_FLAGS_DEFAULT);
function EsButton *EsDialogAddButton(EsDialog *dialog, EsButtonFlags flags = ES_FLAGS_DEFAULT, EsStyleID style = 0, STRING label = BLANK_STRING, EsCommandCallback callback = ES_NULL) @todo();
function void EsDialogClose(EsDialog *dialog);
function EsElement *EsDialogGetContentArea(EsDialog *dialog);

function void EsFileMenuAddToToolbar(EsElement *toolbar, const EsFileMenuSettings *settings = ES_NULL) @in(settings);
function void EsFileMenuCreate(ES_INSTANCE_TYPE *instance, EsElement *parent, EsMenuFlags flags = ES_FLAGS_DEFAULT);

private function EsHandle _EsWindowGetHandle(EsWindow *window); 
private function void _EsUISetFont(EsFontFamily id);

// Buttons.

function EsButton *EsButtonCreate(EsElement *parent, EsButtonFlags flags = ES_FLAGS_DEFAULT, EsStyleID style = 0, STRING label = BLANK_STRING);
function void EsButtonSetIcon(EsButton *button, uint32_t iconID);
function void EsButtonSetIconFromBits(EsButton *button, const uint32_t *bits, size_t width, size_t height, size_t stride) @matrix_in(bits, width, height, stride);
function void EsButtonSetCheck(EsButton *button, EsCheckState checkState = ES_CHECK_CHECKED, bool sendUpdatedMessage = true);
function EsCheckState EsButtonGetCheck(EsButton *button);
function void EsButtonOnCommand(EsButton *button, EsCommandCallback callback) @todo(); // TODO Public property?
function void EsButtonSetCheckBuddy(EsButton *button, EsElement *checkBuddy); // The buddy element is enabled/disabled when the button is checked/unchecked.
function EsElement *EsButtonGetCheckBuddy(EsButton *button);  // TODO Public property?

// Textboxes.

function EsTextbox *EsTextboxCreate(EsElement *parent, EsTextboxFlags flags = ES_FLAGS_DEFAULT, EsStyleID style = 0);
function bool EsTextboxFind(EsTextbox *textbox, STRING string, int32_t *line, int32_t *byte, EsTextboxFindFlags flags) @out(line) @out(byte);
function void EsTextboxInsert(EsTextbox *textbox, STRING string = BLANK_STRING, bool sendUpdatedMessage = true); // Deletes existing selection first.
function void EsTextboxAppend(EsTextbox *textbox, STRING string = BLANK_STRING, bool sendUpdatedMessage = true); // Ignores the user's selection.
function char *EsTextboxGetContents(EsTextbox *textbox, size_t *bytes = ES_NULL, EsTextboxGetContentsFlags flags = ES_FLAGS_DEFAULT) @heap_buffer_out(return, bytes*) @out(bytes); // Result will be zero-terminated; free with EsHeapFree.
function double EsTextboxGetContentsAsDouble(EsTextbox *textbox, EsTextboxGetContentsFlags flags = ES_FLAGS_DEFAULT); 
function size_t EsTextboxGetLineLength(EsTextbox *textbox, uintptr_t line = 0);
function void EsTextboxGetSelection(EsTextbox *textbox, int32_t *fromLine, int32_t *fromByte, int32_t *toLine, int32_t *toByte) @out(fromLine) @out(fromByte) @out(toLine) @out(toByte);
function void EsTextboxMoveCaret(EsTextbox *textbox, int32_t line, int32_t byte);
function void EsTextboxSetSelection(EsTextbox *textbox, int32_t fromLine, int32_t fromByte, int32_t toLine, int32_t toByte);
function void EsTextboxSelectAll(EsTextbox *textbox);
function void EsTextboxClear(EsTextbox *textbox, bool sendUpdatedMessage);
function void EsTextboxUseNumberOverlay(EsTextbox *textbox, bool defaultBehaviour);
function void EsTextboxUseBreadcrumbOverlay(EsTextbox *textbox); 
function void EsTextboxMoveCaretRelative(EsTextbox *textbox, EsTextboxMoveCaretRelativeFlags flags);
function void EsTextboxEnsureCaretVisible(EsTextbox *textbox, bool verticallyCenter = false);
function void EsTextboxSetUndoManager(EsTextbox *textbox, EsUndoManager *manager);
function void EsTextboxSetTextSize(EsTextbox *textbox, uint16_t size);
function void EsTextboxSetFont(EsTextbox *textbox, EsFont font);
function void EsTextboxSetupSyntaxHighlighting(EsTextbox *textbox, EsSyntaxHighlightingLanguage language, const uint32_t *customColors = ES_NULL, size_t customColorCount = 0) @array_in(customColors, customColorCount);
function void EsTextboxStartEdit(EsTextbox *textbox);
function void EsTextboxEnableSmartReplacement(EsTextbox *textbox, bool enabled); // e.g. smart quotes.
function void EsTextboxSetReadOnly(EsTextbox *textbox, bool readOnly); // Prevents the user from modifying the contents of the textbox; EsTextboxInsert will still work. Incompatible with ES_TEXTBOX_EDIT_BASED. Undo events will not be created.

// Sliders.

function EsSlider *EsSliderCreate(EsElement *parent, EsSliderFlags flags = ES_FLAGS_DEFAULT, EsStyleID style = 0, double value = 0, uint32_t steps = 0);
function double EsSliderGetValue(EsSlider *slider);
function void EsSliderSetValue(EsSlider *slider, double newValue, bool sendUpdatedMessage = true);

// Panels, spacers and splitters.

// Styles for panels:
//	Visual:
// 		ES_STYLE_PANEL_DOCUMENT - same background color as textbox - use to contain textual content
//		ES_STYLE_PANEL_FILLED - same background color as window - use to contain a page of controls
//		ES_STYLE_PANEL_INSET, ES_STYLE_PANEL_GROUP_BOX, ES_STYLE_PANEL_SHEET - use for grouping controls
//	Layout:
//		ES_STYLE_PANEL_FORM_TABLE - use for laying out controls in a table
//		ES_STYLE_PANEL_POPUP - use for laying out controls in a menu popup
//	Root level (the root panel/splitter should be one of these):
//		ES_STYLE_PANEL_WINDOW_DIVIDER - does not give the window a background color
//		ES_STYLE_PANEL_WINDOW_BACKGROUND - gives the window a background color, same as ES_STYLE_PANEL_FILLED
//		ES_STYLE_PANEL_WINDOW_WITH_STATUS_BAR_CONTENT - alternate version of ES_STYLE_PANEL_WINDOW_DIVIDER if the window has a status bar

function EsPanel *EsPanelCreate(EsElement *parent, EsPanelFlags flags = ES_FLAGS_DEFAULT, EsStyleID style = 0);
function EsSpacer *EsSpacerCreate(EsElement *parent, EsSpacerFlags flags = ES_FLAGS_DEFAULT, EsStyleID style = 0, int width = 0, int height = 0);
function EsSplitter *EsSplitterCreate(EsElement *parent, EsSplitterFlags flags = ES_FLAGS_DEFAULT, EsStyleID style = 0);
function EsCanvasPane *EsCanvasPaneCreate(EsElement *parent, EsCanvasPaneFlags flags = ES_FLAGS_DEFAULT, EsStyleID style = 0);

function void EsPanelSetBands(EsPanel *panel, size_t columnCount, size_t rowCount = 0, const EsPanelBand *columns = ES_NULL, const EsPanelBand *rows = ES_NULL) @array_in(columns, columnCount) @array_in(rows, rowCount);
function void EsPanelSetBandsAll(EsPanel *panel, const EsPanelBand *column = ES_NULL, const EsPanelBand *row = ES_NULL) @in(column) @in(row); // Set all the columns/rows to have the same properties. This must be called after the final number of bands has been determined/set!
function void EsPanelTableSetChildCells(EsPanel *panel); // Automatically set the child cells for items in a table. This is only necessary if the number of columns/rows is changed after adding items to a table.
function void EsPanelTableAddBandDecorator(EsPanel *panel, EsPanelBandDecorator decorator);

function void EsPanelSwitchTo(EsPanel *panel, EsElement *targetChild, EsTransitionType transitionType, EsPanelSwitchToFlags flags = ES_FLAGS_DEFAULT, float timeMultiplier = 1); // TODO More customization of transitions?
function void EsPanelStartMovementAnimation(EsPanel *panel, float timeMultiplier = 1); // TODO More customization.

function EsButton *EsPanelRadioGroupGetChecked(EsPanel *panel);

function void EsSpacerChangeStyle(EsSpacer *spacer, EsStyleID newStyle);

// Static displays.

function EsIconDisplay *EsIconDisplayCreate(EsElement *parent, EsIconDisplayFlags flags = ES_FLAGS_DEFAULT, EsStyleID style = 0, uint32_t iconID = 0);
function void EsIconDisplaySetIcon(EsIconDisplay *display, uint32_t iconID);

function EsImageDisplay *EsImageDisplayCreate(EsElement *parent, EsImageDisplayFlags flags = ES_FLAGS_DEFAULT, EsStyleID style = 0);
function void EsImageDisplayLoadBits(EsImageDisplay *display, const uint32_t *bits, size_t width, size_t height, size_t stride) @matrix_in(bits, width, height);
function void EsImageDisplayLoadFromMemory(EsImageDisplay *display, const void *buffer, size_t bufferBytes) @buffer_in(buffer, bufferBytes);
function void EsImageDisplayPaint(EsImageDisplay *display, EsPainter *painter, EsRectangle bounds);
function uint32_t EsImageDisplayGetImageWidth(EsImageDisplay *display);
function uint32_t EsImageDisplayGetImageHeight(EsImageDisplay *display);

function EsTextDisplay *EsTextDisplayCreate(EsElement *parent, EsTextDisplayFlags flags = ES_FLAGS_DEFAULT, EsStyleID style = 0, STRING label = BLANK_STRING);
function void EsTextDisplaySetContents(EsTextDisplay *display, STRING contents = BLANK_STRING);
function void EsTextDisplaySetStyledContents(EsTextDisplay *display, const char *string, EsTextRun *runs, size_t runCount) @todo(); // See EsTextPlanCreate for how runCount works.
function void EsTextDisplaySetupSyntaxHighlighting(EsTextDisplay *display, EsSyntaxHighlightingLanguage language, const uint32_t *customColors = ES_NULL, size_t customColorCount = 0) @array_in(customColors, customColorCount);

function EsListDisplay *EsListDisplayCreate(EsElement *parent, EsListDisplayFlags flags = ES_FLAGS_DEFAULT, EsStyleID style = 0);
function void EsListDisplaySetCounterContinuation(EsListDisplay *display, EsListDisplay *previous);
function void EsListDisplaySetCounterStart(EsListDisplay *display, uintptr_t index); // If index = 0, then the first item will be "1." or "(a)".

function void EsAnnouncementShow(EsWindow *window, EsAnnouncementFlags flags, int32_t x, int32_t y, STRING text = BLANK_STRING);

// Color wells.

function EsColorWell *EsColorWellCreate(EsElement *parent, EsColorWellFlags flags = ES_FLAGS_DEFAULT, uint32_t colorRGB = 0);

function uint32_t EsColorWellGetRGB(EsColorWell *well); // TODO Public property?
function void EsColorWellSetRGB(EsColorWell *well, uint32_t colorRGB, bool sendChangedMessage);
function void EsColorWellSetIndeterminate(EsColorWell *well);

// List views.

function EsListView *EsListViewCreate(EsElement *parent, EsListViewFlags flags = ES_FLAGS_DEFAULT, EsStyleID style = 0, EsStyleID itemStyle = 0, EsStyleID headerItemStyle = 0, EsStyleID footerItemStyle = 0);

function EsListViewIndex EsListViewGetIndexFromItem(EsElement *element, EsListViewIndex *group = ES_NULL) @out(group);
function EsListViewEnumeratedVisibleItem *EsListViewEnumerateVisibleItems(EsListView *view, size_t *count) @out(count) @heap_array_out(return, count*);

function void EsListViewRegisterColumn(EsListView *view, uint32_t id, STRING title = BLANK_STRING, EsListViewColumnFlags flags = ES_FLAGS_DEFAULT, double initialWidth = 0);
function void EsListViewAddAllColumns(EsListView *view); // Call after registering the columns to add them to the header. Call again after EsListViewChangeStyles, as needed.
function void EsListViewSetEmptyMessage(EsListView *view, STRING message = BLANK_STRING);
function void EsListViewSetMaximumItemsPerBand(EsListView *view, int maximumItemsPerBand);
function void EsListViewSelectNone(EsListView *view);
function void EsListViewSelect(EsListView *view, EsListViewIndex group, EsListViewIndex index, bool addToExistingSelection = false);
function void EsListViewFocusItem(EsListView *view, EsListViewIndex group, EsListViewIndex index);
function bool EsListViewGetFocusedItem(EsListView *view, EsListViewIndex *group, EsListViewIndex *index) @out(group) @out(index); // Returns false if not item was focused.
function void EsListViewInvalidateContent(EsListView *view, EsListViewIndex group, EsListViewIndex index);
function void EsListViewInvalidateAll(EsListView *view);
function void EsListViewContentChanged(EsListView *view);
function void EsListViewChangeStyles(EsListView *view, EsStyleID style, EsStyleID itemStyle, EsStyleID headerItemStyle, EsStyleID footerItemStyle, uint32_t addFlags, uint32_t removeFlags);
function void EsListViewScrollToEnd(EsListView *view);
function EsPoint EsListViewGetAnnouncementPointForSelection(EsListView *view);

function EsTextbox *EsListViewCreateInlineTextbox(EsListView *view, EsListViewIndex group, EsListViewIndex index, EsListViewInlineTextboxFlags flags = ES_FLAGS_DEFAULT);

// (Callback items.)
function void EsListViewInsertGroup(EsListView *view, EsListViewIndex group, EsListViewGroupFlags flags = ES_FLAGS_DEFAULT);
function void EsListViewInsert(EsListView *view, EsListViewIndex group, EsListViewIndex firstIndex, EsListViewIndex count);
function void EsListViewRemove(EsListView *view, EsListViewIndex group, EsListViewIndex firstIndex, EsListViewIndex count);
function void EsListViewRemoveAll(EsListView *view, EsListViewIndex group);
// (Fixed items.)
function EsListViewIndex EsListViewFixedItemInsert(EsListView *view, EsGeneric data = ES_NULL, EsListViewIndex index = -1, uint32_t iconID = 0);
function bool EsListViewFixedItemRemove(EsListView *view, EsGeneric data); // Returns false if the item was not found.
function void EsListViewFixedItemSetString(EsListView *view, EsListViewIndex index, uint32_t columnID, STRING string = BLANK_STRING);
function void EsListViewFixedItemSetDouble(EsListView *view, EsListViewIndex index, uint32_t columnID, double number);
function void EsListViewFixedItemSetInteger(EsListView *view, EsListViewIndex index, uint32_t columnID, int64_t number);
function bool EsListViewFixedItemSelect(EsListView *view, EsGeneric data); // Returns false if the item was not found.
function bool EsListViewFixedItemGetSelected(EsListView *view, EsGeneric *data) @out(data); // Returns false if no item was selected.
function void EsListViewFixedItemSetEnumStringsForColumn(EsListView *view, uint32_t columnID, const EsListViewEnumString *strings, size_t stringCount) @array_in(strings, stringCount);
function void EsListViewFixedItemSortAll(EsListView *view); // Re-sort the list after inserting new items or modifying existing items. TODO EsListViewFixedItemSortSingleItem.
